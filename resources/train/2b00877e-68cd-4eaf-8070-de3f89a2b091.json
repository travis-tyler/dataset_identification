[{"section_title": "Abstract", "text": "Autoencoder-based learning has emerged as a staple for disciplining representations in unsupervised and semi-supervised settings. This paper analyzes a framework for improving generalization in a purely supervised setting, where the target space is high-dimensional. We motivate and formalize the general framework of targetembedding autoencoders (TEA) for supervised prediction, learning intermediate latent representations jointly optimized to be both predictable from features as well as predictive of targets-encoding the prior that variations in targets are driven by a compact set of underlying factors. As our theoretical contribution, we provide a guarantee of generalization for linear TEAs by demonstrating uniform stability, interpreting the benefit of the auxiliary reconstruction task as a form of regularization. As our empirical contribution, we extend validation of this approach beyond existing static classification applications to multivariate sequence forecasting, verifying their advantage on both linear and nonlinear recurrent architectures-thereby underscoring the further generality of this framework beyond feedforward instantiations."}, {"section_title": "INTRODUCTION", "text": "Representation learning deals with uncovering useful underlying structures of data, and autoencoders (Hinton & Salakhutdinov, 2006) have been a staple in a variety of problems. While much research focuses on its use in unsupervised or semi-supervised settings with such diverse objectives as sparsity (Ranzato et al., 2007) , generation (Kingma & Welling, 2013) , and disentanglement (Chen et al., 2018) , autoencoders are also useful in purely supervised settings-in particular, adding an auxiliary feature-reconstruction task to supervised classification problems has been shown to empirically improve generalization (Le et al., 2018) ; in the linear case, the theoretically quantifiable benefit matches that of simplistic norm-based regularization (Bousquet & Elisseeff, 2002; Rosasco & Poggio, 2009) .\nIn this paper, we consider the inverse problem setting where the target space Y is high-dimensional; for instance, consider the multi-label classification tasks of object tagging, text annotation, and image segmentation. This is in contrast to the vast majority of works designed to tackle a high-dimensional feature space X (where commonly |X | |Y|, such as in standard classification problems). In this setting, the usual (and universal) strategy of learning to reconstruct features (Weston et al., 2012; Kingma et al., 2014; Le et al., 2018) may not be most useful: learning latent representations that encapsulate the variation within X does not directly address the more challenging problem of mapping back up to a higher-dimensional Y. Instead, we argue for leveraging intermediate representations that are compact and more easily predictable from features, yet simultaneously guaranteed to be predictive of targets. In the process, we provide a unified theoretical perspective on recent applications of autoencoders to label-embedding in static, high-dimensional classification problems (Yu et al., 2014; Girdhar et al., 2016; Yeh et al., 2017) . Extending into the temporal setting, we further empirically demonstrate the generality of target-embedding for recurrent, multi-variate sequence forecasting.\nOur contributions are three-fold. First, we motivate and formalize the target-embedding autoencoder (TEA) framework: a general approach applicable to any underlying architecture. Second, we provide a theoretical learning guarantee in the linear case by demonstrating uniform stability; specifically, we obtain an O(1/N ) bound on instability by analogizing the benefit of the auxiliary reconstruction task to a form of regularization-without incurring additional bias from explicit shrinkage. Finally, we extend empirical validation of this approach beyond the domain of static classification: using the task of multivariate disease trajectory forecasting as case study, we experimentally validate the for wa rd (sh ar ed ) em be d predict Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (b) Target-Embedding Autoencoder (a) Feature-Embedding Autoencoder Figure 1 : (a) Feature-embedding and (b) Target-embedding autoencoders. Solid lines correspond to the (primary) prediction task; dashed lines to the (auxiliary) reconstruction task. Shared components are involved in both.\nadvantage that TEAs confer on both linear and nonlinear architectures using real-world datasets with both continuous and discrete targets. To the best of our knowledge, we are the first to formalize and quantify the theoretical benefit of autoencoder-based target-representation learning in a purely supervised setting, and to extend its application to the domain of multivariate sequence forecasting."}, {"section_title": "TARGET-EMBEDDING AUTOENCODERS", "text": "Let X and Y be finite-dimensional vector spaces, and consider the supervised learning problem of predicting targets y \u2208 Y from features x \u2208 X . With a finite batch of N training instances D = {(x n , y n )} N n=1 , the objective is to learn a mapping h : X \u2192 Y that generalizes well to new samples from the same distribution. The vast majority of existing work consider the setting-most commonly, classification-where |X | |Y|; under this scenario, autoencoders are often used to first transform the input into some lower-dimensional representation z \u2208 Z amenable to the downstream task. Doing so involves adding an auxiliary reconstruction loss r to the primary prediction loss p .\nFormally, solutions of this form-in supervised and semi-supervised settings alike-consist of a shared forward model \u03c6 : X \u2192 Z, a reconstruction function r : Z \u2192 X , and a prediction function d : Z \u2192 Y during training (where notation d reflects the downstream nature of the prediction task). Denotex = r(\u03c6(x)) and\u0177 = d(\u03c6(x)); then the complete loss function takes the following form,\nIn contrast, we focus on settings where the target space Y is high-dimensional, and where possibly |Y| > |X |. In this case, we argue that learning to reconstruct the input is not necessarily most beneficial. In a simple classification problem, autoencoding inputs leverages the hypothesis that a reconstructive representation is also likely discriminative. In our setting, however, the more immediate problem is the high-dimensional structure of Y; in particular, there is little guarantee that intermediate representations trained to encapsulate x are easily mapped back up to higher-dimensional targets.\nOur goal is to make use of intermediate representations that are both predictable from features as well as predictive of targets. A target-embedding autoencoder (TEA)-versus what we shall term a feature-embedding autoencoder (FEA)-flips the model architecture around by learning an embedding of target vectors instead, which a predictor then learns a mapping into. This involves an encoder e : Y \u2192 Z, an upstream predictor u : X \u2192 Z, and a shared forward model \u03b8 : Z \u2192 Y. Denote\u1ef9 = \u03b8(e(y)) and\u0177 = \u03b8(u(x)); the complete loss function is now of the following form,\n(2) @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >"}, {"section_title": "Latent Code", "text": "\n\n\n\n\nFeature Vector 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > Predictio\u01f9 p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = d(\u1e91; W d ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W d < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (a) Base; REG\n\n"}, {"section_title": "Prediction Reconstruction", "text": "Feature Vector 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >`r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > x = r(\u1e91; W r ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = d(\u1e91; W d ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1e91 = (x; ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W d < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (a) Feature-Embedding Autoencoder embeddings (generated by the encoder): the parameters of u are learned (on the latent loss) while the autoencoder is frozen. Finally, all three components are jointly trained on both prediction and reconstruction losses (Equation 2): parameters of the predictor, embedding, and shared forward model are trained simultaneously. Note that during training, the forward model receives two types of latents as input: encodings of true targets, as well as encodings predicted from features. At inference time, the target-embedding arm is dropped, leaving the learned hypothesis h = \u03b8 \u2022 u for prediction. Figure  4 (Appendix C) provides step-by-step block diagrams of both training and inference in greater detail.\nWe emphasize that TEAs-as is the case with FEAs-specify a general framework independent of the implementation details of each component. For instance, the solutions to applications in Yu et al. (2014) , Yeh et al. (2017) , and Girdhar et al. (2016) can be abstractly regarded as linear and nonlinear instances of this framework, with domain-specific architectures (see Section 4 and Appendix B for more detailed discussions). Linear TEAs-which we study in greater detail in Section 3-involve parameterizations (\u0398, W u , W e ) of (\u03b8, u, e) consisting of single hidden layers with linear activation.\nTarget Vector Feature Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1ef9 = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (a) Training (Stage 1) 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\nTarget Vector Feature Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(\u1e91; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1ef9 = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (c) Training (Stage 3), TEA 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\nTarget Vector Feature Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (b) Training (Stage 2) @`z @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >`z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > \nTarget Vector Feature Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(\u1e91; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (f) Inference Time 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > Figure 4 : (continued) the predictor continues to regress the learned embeddings, and the latent loss backpropagates through both u and e (TEA(L)). (e) The TEA(LP) variant combines the previous two: both the latent loss and prediction loss are trained jointly together with the reconstruction loss. (f) At inference time, the target-embedding arm is dropped, leaving the hypothesis h = \u03b8 \u2022 u for prediction.\nFeature Vector 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >`r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > x = r(\u1e91; W r ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = d(\u1e91; W d ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1e91 = (x; ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W d < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (b) FEA @`p @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1e91 = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (a) The baseline is direct prediction (with (REG) and without (Base) 2 -regularization), which simply corresponds to removing the autoencoder; here we explicitly identify some intermediate hidden layer to preserve visual correspondence with the autoencoder models, but note that the \"latent code\" is strictly speaking a misnomer-as nothing is being encoded here. (b) FEAs consist of a shared forward Latent Code Prediction Feature Vector 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >x = r(\u1e91; W r ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = (x; ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (d) F/TEA Reconstruction Target Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > Reconstruction 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >`r X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >`r Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r X @W r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(\u1e91; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r X @ < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r Y @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r Y @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\nTarget Vector Feature Vector 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(\u1e91; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1ef9 = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (c) TEA 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > clinical visits. We focus on the 8 primary quantitative biomarkers (e.g. entorhinal cortex, fusiform gyrus, hippocampus), 16 cognitive tests (e.g. ADAS11, CDR sum of boxes, mini mental state exam), as well as static demographic information (e.g. apolipoprotein E4, education level, ethnicity); we omit the remaining variables, for which the rate of missingness is over 50%. Using a precedent window, we forecast the future the evolution of the primary quantitative biomarkers and cognitive test results (all continuous variables) measured at each visit. The Medical Information Mart for Intensive Care records physiological data streams patients admitted to intensive care units after 2008. We use over 22,000 patients with a total of over 500,000 measurements (resampled at 4 hour intervals). We focus on the most frequently measured vital signs and lab tests (e.g. heart rate, oxygen saturation, respiratory rate) recorded over time (with categorical variables binarized, this gives a total of 361 variables), as well as static demographic information (e.g. admission type, gender, location, marital status); we omit the remaining variables, for which the rate of missingness is over 50%. Using a precedent window, we forecast the subsequent window of those variables. For each dataset, sequences are randomized at the patient level in order to obtain splits for training (and validation) and testing.\nWe implement all models using Tensorflow. For the linear model, each component (encoder, decoder, and predictor) consists of a single layer, no bias term, and linear activation; static (demographic) and temporal data are concatenated and flattened for both features and targets. For the nonlinear case, we implement each component as an RNN using GRUs with the number of hidden layers \u03b6 \u2208 {1, 2} where the number of hidden units is equal to the temporal feature dimension, and tanh is used for activation; the dimension of the latent space is (therefore) equal to the hidden state dimension. (For even larger hidden capacities, the increased number of parameters rapidly degrades performance). Static (demographic) information is incorporated as a mapping into the initial state for recurrent cells. Training is performed using the ADAM optimizer with a learning rate of \u03c8 \u2208 {3e\u22125, 3e\u22124, 3e\u22123, 3e\u22122}. Models are trained until convergence up to a maximum of 10,000 iterations with a minibatch size of N s \u2208 {32, 64, 128}; the empirical loss is computed on the validation set every 50 iterations of training, and convergence is determined on the basis of that error. Checkpointing is implemented every 50 iterations, and the best model parameters are restored (upon convergence) for use on the testing set. For all models except \"Base\", we allow the opportunity to select among the 2 -regularization coefficients \u03bd \u2208 {0, 3e\u22125, 3e\u22124, 3e\u22123, 3e\u22122}. We set the strength-of-prior coefficient \u03bb = 0.5 for FEA, F/TEA, as well as all variants of TEA (however, we do provide sensitivities on \u03bb for TEA in our experiments). For hyperparameter tuning (\u03b6, \u03c8, \u03bd, N s ), we use cross-validation on the training set using 20 iterations of random search, selecting the setting that gives the lowest validation loss averaged across folds. For fair comparison (so as to isolate the effect of supervised representation learning over and above direct prediction), we apply the same setting chosen for REG for FEA, F/TEA, and all variants of TEA; therefore the only difference is the presence Published as a conference paper at ICLR 2020 or absence of each autoencoding component. For each model and dataset, the experiment is repeated for a total of 10 times (each with a different random split of data into training and held-out testing sets); all results are reported as means and standard errors of each performance metric across runs. 0.419 \u00b1 0.012* 3 0.314 \u00b1 0.088* 0.337 \u00b1 0.076* 0.342 \u00b1 0.071* 0.432 \u00b1 0.015 0.399 \u00b1 0.013* 4 0.307 \u00b1 0.082* 0.328 \u00b1 0.071* 0.333 \u00b1 0.067* 0.413 \u00b1 0.010 0.386 \u00b1 0.009* PRC(C) 1 0.445 \u00b1 0.131* 0.467 \u00b1 0.106* 0.499 \u00b1 0.110* 0.653 \u00b1 0.009 0.599 \u00b1 0.019* 2 0.418 \u00b1 0.099* 0.435 \u00b1 0.081* 0.457 \u00b1 0.083* 0.566 \u00b1 0.010 0.524 \u00b1 0.017* 3 0.403 \u00b1 0.082* 0.418 \u00b1 0.067* 0.436 \u00b1 0.069* 0.521 \u00b1 0.008 0.487 \u00b1 0.015* 4 0.398 \u00b1 0.073* 0.412 \u00b1 0.060* 0.426 \u00b1 0.061* 0.498 \u00b1 0.009 0.471 \u00b1 0.013* ROC(I) 1 0.713 \u00b1 0.104* 0.737 \u00b1 0.081* 0.750 \u00b1 0.078 0.806 \u00b1 0.007 0.801 \u00b1 0.007 2 0.688 \u00b1 0.089* 0.709 \u00b1 0.070* 0.718 \u00b1 0.068* 0.771 \u00b1 0.007 0.765 \u00b1 0.009 3 0.677 \u00b1 0.080* 0.697 \u00b1 0.065* 0.706 \u00b1 0.066 0.750 \u00b1 0.007 0.749 \u00b1 0.009 4 0.677 \u00b1 0.076* 0.696 \u00b1 0.063 0.707 \u00b1 0.068 0.740 \u00b1 0.008 0.748 \u00b1 0.006* ROC(C) 1 0.713 \u00b1 0.110* 0.741 \u00b1 0.088* 0.756 \u00b1 0.084* 0.829 \u00b1 0.006 0.810 \u00b1 0.008* 2 0.686 \u00b1 0.091* 0.707 \u00b1 0.072* 0.719 \u00b1 0.071* 0.775 \u00b1 0.008 0.762 \u00b1 0.008* 3 0.668 \u00b1 0.077* 0.686 \u00b1 0.061* 0.699 \u00b1 0.063 0.743 \u00b1 0.005 0.735 \u00b1 0.007* 4 0.651 \u00b1 0.070* 0.667 \u00b1 0.056* 0.679 \u00b1 0.057* 0.720 \u00b1 0.006 0.712 \u00b1 0.009* PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result. Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. 0.722 \u00b1 0.007 0.720 \u00b1 0.006 0.713 \u00b1 0.008 0.720 \u00b1 0.006 PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining). PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining)."}, {"section_title": "STABILITY-BASED LEARNING GUARANTEE", "text": "Two questions are outstanding. The first is theoretical. We are motivated by the prior that variations in target space are driven by a lower-dimensional set of underlying factors. In this context, can we say something more rigorous about the benefit of TEAs? In this section, we take the first step in showing that jointly learning target representations improves generalization performance in the supervised setting. Specifically, we demonstrate that linear TEAs are characterized by uniform stability, from which theoretical guarantees are known to follow. The second question is empirical. We noted above that certain applications of label-embedding to classification can be interpreted through this framework. Does the benefit extend beyond its static, feedforward instantiations-into the temporal setting for multi-variate sequence forecasting, with both continuous and discrete targets? In Section 5, we first validate our theoretical findings with linear models and sensitivities, as well as extending our empirical analysis to the realm of recurrent, nonlinear models for both regression and classification.\nConsider a linear TEA, where the upstream predictor is parameterized by W u \u2208 R |Z|\u00d7|X | , targetembedding by W e \u2208 R |Z|\u00d7|Y| , and shared forward model by \u0398 \u2208 R |Y|\u00d7|Z| , where |Z| < |Y|. The complete loss function is given by L = 1 N N n=1 [ p (\u0398W u x n , y n ) + r (\u0398W e y n , y n )] following Equation 2. Interpreting the jointly learned autoencoding component as an auxiliary task, we show that the TEA algorithm for learning the shared forward model \u0398 is uniformly stable with respect to the domain of the supervised prediction task. To establish our notation, first recall the following:\nDefinition 1 (Generalization Bound) Given a learning algorithm D \u2192 h D that returns hypothesis h D , let R(h D ) = (h D (x), y)d\u00b5(x, y) denote the risk, andR(h D ) = 1 N N n=1 (h D (x n ), y n ) denote the empirical risk, where is some loss function. A generalization bound is a probabilistic bound on the defect that takes the following form:\nDefinition 2 (Uniform Stability) Let D i denote a modification of batch D where the i-th training instance (x i , y i ) is replaced by an independent and identically distributed example (x i , y i ). A learning algorithm is said to be \u03b3-uniformly stable with respect to the loss function if \u2200D \u2208\nUniform stability holds if the minimum value of \u03b3 converges to zero as batch size N increases without limit.\nUniform stability can be used to derive algorithm-dependent generalization bounds. In particular, Bousquet & Elisseeff (2002) first showed that the defect of a \u03b3-uniformly stable algorithm is is less than O((\u03b3 + 1/N ) N log(1/\u03b4)) with probability \u2265 1 \u2212 \u03b4. Feldman & Vondrak (2018) recently demonstrated an improved bound of O( (\u03b3 + 1/N ) log(1/\u03b4)). Here, we show uniform stability for linear TEAs, where \u03b3 is O(1/N )-by which a tight generalization bound follows immediately. Before we begin, we introduce two additional tools: c-strong convexity and \u03c3-admissibility. Note that these conditions are standard and easily satisfied-for instance, by the quadratic loss function; for more context see for example Bousquet & Elisseeff (2002) , Liu et al. (2016), and Mohri et al. (2018) .\n, y) denotes the gradient with respect to h(x), and \u00b7, \u00b7 denotes the dot product operation.\nDefinition 4 (\u03c3-Admissibility) Loss function is \u03c3-admissible with respect to the underlying hy-\nTo obtain uniform stability, we make two assumptions-both analogous to prior work arguing from the benefit of learning shared models between tasks. Liu et al. (2016) deals with learning multiple tasks in general, and Le et al. (2018) deals with reconstructing inputs in what we describe as FEAs. Now in multi-task learning, the separate tasks are usually chosen due to some prior relationship between them. In the case of Assumption 1 in Liu et al. (2016) and Assumption 5 in Le et al. (2018) , this is assumed to come from similarities in feature structures across tasks; hence their assumptions of cross-representability are made in feature space. (Note that this restricts primary and auxiliary features to be elements of the same space). Our setting is contrary: the inputs to primary and auxiliary tasks come from different spaces, but are trained to produce similar labels through a compact, shared latent space; hence our assumption of cross-representability will be made in this latent space instead.\nAssumption 1 (Representative Vectors) There exists a representative subset of target vectors B = {b 1 , ..., b M } \u2282 {y 1 , ..., y N } such that the latent representation of any individual (x, y) can be linearly reconstructed from that of the representative subset with small error, i.e.\n\u03b2 for some r \u03b1 , r \u03b2 \u2208 R + , and \u03b7 is a small error satisfying \u03b7 2 \u2264 \u03b5. Remark 1 This assumption is comparatively mild, even for \u03b5 = 0. Note that in Liu et al. (2016) the features for separate tasks come from different examples in general, and the similarity of their distributions within X is simply assumed. Here, each pair of inputs to the prediction and reconstruction tasks comes from the same instance, and similarity within Z is explicitly enforced through the (joint) training objective. In addition, observe that the assumption will hold with zero error as long as the number of independent latent vectors is at least |Z|. Furthermore, unlike the scenarios in Liu et al. (2016) and Le et al. (2018) we do not require that the input domains of the two tasks be identical. Therefore for ease of exposition, we assume going forward that \u03b5 = 0 (see Remark 6 in Appendix A). Remark 2 A comparison with Assumption 4 in Le et al. (2018) sheds additional light on why we expect TEAs to be beneficial where |Y| > |Z|, in contrast with the (more typical) scenario |X | > |Z| |Y|. Critically, the technique in Le et al. (2018) banks on the fact that the prediction arm projects the latent into a lower-dimensional target space. Conversely, Assumption 1 here relies on the fact that the encoding arm maps into the latent space from a higher-dimensional target space (rendering cross-representability therein reasonable). The distinction is crucial: we certainly do not expect any benefit from autoencoding trivially low-dimensional vectors! Note also that here the representative vectors are taken from Y; to take them from X instead would be unreasonable. For any compressive autoencoder, we generally expect if some subset {b 1 , ..., b M } \u2282 {y 1 , ..., y N } spans Y that {W e b 1 , ..., W e b M } then also span Z in order to be maximally reconstructive. The same cannot be said of subsets {c 1 , ..., c M } \u2282 {x 1 , ..., x N } that span X -for instance, take |X | \u2264 |Z|.\nIn addition to being representative in terms of latent values, the set of representative points also needs to be representative in terms of the reconstruction error. First, let L denote the counterpart\n;n =i ( p (\u0398W u x n , y n ) + r (\u0398W e y n , y n ))]. Then, let \u0398 * , \u0398 * denote the optimal parameters corresponding to the two losses L and L .\nAssumption 2 (Representative Errors) Let L r contain the reconstruction errors of the dataset without the i-th sample: L r = (1/N )\u03a3 N n=1;n =i r (\u0398W e y n , y n ), and let L B r denote the reconstruction error of the representative subset:\nThen there exists some a > 0 such that for any small \u03ba > 0 :\nThat is, the difference in reconstruction error L B r between the two points \u0398 * , \u0398 * is upper bounded by some constant factor of the corresponding difference in reconstruction error L r at the two points. Importantly, note that this does not require that the values of the errors L r and L B r themselves be similar, only that their differences be similar. This assumption is identical to Assumption 6 in Le et al. (2018) , and plays an identical role: we make use of L B r -which is only dependent on M -to allow the bound to decay with N ; this is in contrast with the generic multi-task analysis of Liu et al. (2016) , which-if applied directly to TEAs (as with FEAs)-would give a bound that does not decay with N .\nTheorem 1 (Uniform Stability) Let p and r be \u03c3 p -admissible and \u03c3 r -admissible loss functions, and let r be c-strongly convex. Then under Assumptions 1 and 2, the following inequality holds,\nCorollary 1 (Generalization Bound) Consider the same conditions as in Theorem 1; that is, let p and r be \u03c3 p -admissible and \u03c3 r -admissible losses, and let r be c-strongly convex. Then under Assumptions 1 and 2, the defect is less than O( (1/N ) log(1/\u03b4)) with probability at least 1 \u2212 \u03b4.\nProof. Follows immediately from Theorem 1 (above) and either of the following (similar results hold for both): Theorem 1.2 (Feldman & Vondrak, 2018) , and Theorem 12 (Bousquet & Elisseeff, 2002) .\nIn supervised learning, it is often easy to make an argument-on an intuitive level-for the \"regularizing\" effect of additional loss terms. In contrast, this analysis allows us to unambiguously identify and quantify the benefit of the embedding component as a regularizer (see Remark 4 in Appendix A).\nRemark 3 In the linear label space reduction framework of Yu et al. (2014) , uniform convergence is also shown to hold via norm-based regularization. Specifically for uniform stability, a similar bound can also be achieved by adding a strongly convex term to the objective, such as Tikhonov-and 2 -regularization (Bousquet & Elisseeff, 2002; Rosasco & Poggio, 2009; Shalev-Shwartz et al., 2010) . Here, however, the joint reconstruction task leverages a different kind of bias-precisely, the assumption that there exist compact and predictable representations of targets. Therefore the significance of this analysis is that we achieve an equivalent result independent of explicit regularization."}, {"section_title": "RELATED WORK", "text": "Our work straddles three threads of research: (1) supervised representation learning with autoencoders, (2) label space reduction for multi-label classification, and (3) stability-based learning guarantees. Appendix B provides a much expanded treatment, and presents summary tables for additional context.\nSupervised representation learning. While a great deal of research is devoted to uncovering useful underlying structures of data through autoencoders-with various properties such as sparsity (Ranzato et al., 2007) and disentanglement (Chen et al., 2018) , among many others (Tschannen et al., 2018)-the goal of better representations is often for the benefit of downstream tasks. Semi-supervised autoencoders jointly optimized on partially-labeled data can obtain compact representations that improve prediction (Weston et al., 2012; Kingma et al., 2014; Ghifary et al., 2016) . Furthermore, auxiliary reconstruction is also useful in a purely supervised setting: rather than focusing on how specific architectures better structure unlabeled data, Le et al. (2018) show the simple benefit of feature-reconstruction on supervised classification-a special case of what we describe as FEAs.\nIn contrast, we focus on target-representation learning in the supervised setting, and analyze its benefit under the prior that high-dimensional targets are driven by a compact and predictable set of factors.\nWe take inspiration from the empirical study of Girdhar et al. (2016) , where latent representations of 3D objects are jointly trained to be predictable from 2D images. Their setup can be viewed as a specific instance of TEAs with (nonlinear) convolutional components, with a minor variation in training: in the joint stage, predictors continue to regress the learned embeddings, and gradients only backpropagate from latent space (instead of target space). Unlike the symmetry of our losses (which we require for our analysis above), their common decoder is only shared indirectly (and predictions made indirectly). As it turns out, this does not appear to matter for performance (see Section 5). In Mostajabi et al. (2018) , a two-stage procedure is used for semantic segmentation-loosely comparable to the first two stages in TEAs; in contrast to our emphasis on joint training, they study the benefit of a frozen embedding branch in parallel with direct prediction. More broadly related to target-embedding, Dalca et al. (2018) build anatomical priors for biomedical segmentation in unsupervised settings.\nMulti-label classification. The general idea of target space dimension reduction has been explored for multi-label classification problems (commonly, annotation based on bags of features). These first derive a reduced label space, then subsequently associate inputs to it; methods include compressed sensing (Hsu et al., 2009 ), principal components (Tai & Lin, 2010 , maximum-margin coding (Zhang & Schneider, 2012) , and landmarking (Balasubramanian & Lebanon, 2012 Recently, Yeh et al. (2017) generalize the label-embedding approach to autoencoders. This flexibly accommodates custom losses to exploit correlations, as well as deep learning for nonlinearities. Our work is related to this line of research, although we operate at a higher level of abstraction, with a significant difference in focus. Their problem is multi-label classification, and their starting point is binary relevance (i.e. label by label). During reduction, they worry about specific losses that capture dependencies within and among spaces. In contrast, we worry about autoencoding at all-that is, we focus on the effect of joint reconstruction on learning the prediction model. Problems can be of any form: classification or regression, and our starting point is direct prediction (i.e. no reconstruction).\nStability and learning guarantees. Generalizability via hypothesis stability is first studied in Rogers & Wagner (1978) and Devroye & Wagner (1979) ; unlike arguments based on the complexity of the search space (Vapnik & Chervonenkis, 1971; Pollard, 1984; Koltchinskii, 2001) , these account for how the algorithm depends on the data. Bousquet & Elisseeff (2002) first formalize the notion of uniform stability sufficient for learnability, and Feldman & Vondrak (2018) use ideas related to differential privacy (Bassily et al., 2016) for further improvement. Separately, while there is a wealth of research on dimensionality reduction and autoencoders (Singh et al., 2009; Mohri et al., 2015; Gottlieb et al., 2016; Epstein & Meir, 2019) , they either operate in the semi-supervised setting, or focus on the benefit of feature representations (not targets) and also do not consider joint learning.\nThe benefit of jointly learning multiple tasks through a common operator (Caruana, 1997) is explored with VC-based (Baxter, 2000) and Rademacher complexity-based (Maurer, 2006; Maurer et al., 2016) analyses. Recently, Liu et al. (2016) show that the algorithm for learning the shared model in a multi-task setting is uniformly stable. While our argument is based on theirs, we are not interested in a generic bound for all tasks; closer to Le et al. (2018) , we focus on the primary prediction task, and leverage the auxiliary reconstruction task for stability. Similarly, we arrive at an O(1/N ) on instability without an explicit regularization term as in Bousquet & Elisseeff (2002) . Unlike them, however, the fundamental distinction of our setting is that Y is high-dimensional (but where the underlying factors are assumed compact); in this sense our focus is the mirror opposite of theirs."}, {"section_title": "EXPERIMENTS AND DISCUSSION", "text": "So far, we have formalized a general target-autoencoding framework for supervised learning, and quantified the benefit via uniform stability. Our overall goal in this section is to explore this benefit in a simple controlled setting, such that we can identify and isolate its utility on the prediction task, and investigate any sensitivities of interest. By way of preface, we emphasize two observations from above: (1) In the static, multi-label classification setting, the gain from label-embedding has been studied, including the autoencoder approach of Yeh et al. (2017)-which can be viewed as an instantiation of TEAs with sophisticated refinements.\n(2) The benefit of target-autoencoding is also The effective input dimension |X | is computed as the dimension of static data plus the product of the width of the historical window (of temporal information) with its dimension; the effective target dimension |Y| is similarly computed as the product of the width of the forecast window (of temporal information) with its dimension. demonstrated using nonlinear, convolutional architectures in Girdhar et al. (2016) -which is also an instantiation of TEAs, also noting significant gains. Therefore a natural question of interest is:\n\u2022 Does the utility of target-embedding extend to (nonlinear) recurrent models with sequential data for general, high-dimensional targets (i.e. regression and/or classification)?\nDisease Trajectories. In this section, we take the first step in answering this question-as our empirical contribution, we extend validation of target-embedding autoencoders to the domain of multivariate sequence forecasting, exploring its utility on linear and nonlinear sequence-to-sequence architectures. What makes a good testbed? In particular, the progression of diseases (and their markers) is high-dimensional in presentation; at the same time, their evolution is often driven by latent biological dynamics (Szczesniak et al., 2017; Pascoal et al., 2017; Alaa & van der Schaar, 2019) .\nWith the increasing importance of early diagnosis and timely intervention in healthcare, the ability to forecast individual disease trajectories (Y) in the presence of limited windows of information (X ) has become increasingly desirable (Donohue et al., 2014; Pham et al., 2017; Bhagwat et al., 2018) .\nDatasets. We use three datasets in our experiments. The first consists of a cohort of patients enrolled in the UK Cystic Fibrosis registry (UKCF), which records follow-up trajectories for over 10,000 patients. We are interested in forecasting future trajectories for the 11 possible infections and 23 possible comorbidities (all binary variables) recorded at each follow-up, using past trajectories and basic demographics as input. The second consists of patients in the Alzheimer's Disease Neuroimaging Initiative study (ADNI), which tracks disease progression for over 1,700 patients. We are interested in forecasting the evolution of the 8 primary biomarkers and 16 cognitive tests (all continuous variables) measured at each visit, using past measurements and basic demographics as input. The third consists of a cohort of patients in intensive care units from the Medical Information Mart for Intensive Care (MIMIC), which records physiological data streams for over 22,000 patients. Likewise, we are interested in forecasting future trajectories for the 361 most frequently measured variables such as vital signs and lab tests (both binary and continuous variables), again using past measurements and basic demographics as input. See Appendix D for more information on datasets.\nExperimental Setup. In each instance, the prediction input is a precedent window of up to width w x , and the prediction target is the succedent window of width w y . For UKCF (w x , w y ) = (3, 4) at 1-year resolution, for ADNI (4, 8) at 6-month resolution, and for MIMIC (5, 5) at 4-hour (resampled) resolution. All models are implemented in Tensorflow. Linear models consist of a single hidden layer with no nonlinearity; for the nonlinear case, we implement an RNN model for each component using GRUs. See Appendix D for additional detail on model implementation and configuration. For evaluation, we measure the mean squared error (MSE) for continuous targets (averaged across variables), and the area under the precision-recall curve (PRC) and area under the receiver operating characteristic curve (ROC) for binary targets (averaged across variables). We use cross-validation on the training set for hyperparameter tuning, selecting the setting that gives the lowest validation loss averaged across folds. For each model and dataset, we report the average and standard error of each performance metric across 10 different experiment runs, each with a different random train-test split.\nNote that forecasting high-dimensional disease trajectories is challenging, and input information is deliberately limited (as is often the case in medical practice); the desired targets are similar or higherdimensional than the inputs (see Table 1 ). This obviously results in an inherently difficult prediction problem-but which makes for a good candidate setting to test the utility of target-representation learning. RNN autoencoders have previously been proposed for learning representations of inputs (i.e. FEAs instantiated with RNNs) to improve classification (Dai & Le, 2015) , prediction (Lyu et al., 2018) , generation (Srivastava et al., 2015) , and clustering (Baytas et al., 2017) ; similarly, their mission is not in excessively optimizing specific architectural novelties to match state-of-the-art, but rather in exploring the benefit of the autoencoding framework. Here, we learn representations of targets. The two-sample t-test for difference in means is conducted on the results. An asterisk indicates statistically significant difference in means (p-value < 0.05) relative to the TEA result. For UKCF, only PRC metrics for infections (I) and comorbidities (C) are shown due to space limitation; for ADNI, MSE metrics are reported separately for targets representing biomarkers (B) and cognitive tests (C). See [17] [18] [21] [22] "}, {"section_title": "MAIN RESULTS", "text": "Overall Benefit. First, we examine the overall utility of TEAs. To verify the linear case first, Table 2 summarizes the performance of TEA and alternate setups on UKCF. The temporal axis is flattened to simulate ordinary static multi-label classification, and the base case is direct prediction (Base)-that is, absent any auxiliary representation learning or regularization. Next, we allow for 2 -regularization over direct prediction (REG), as well as over all other methods. FEAs differ only by the added feature-reconstruction, and TEAs only by the target-reconstruction; as an additional sensitivity, we also implement a combined approach (F/TEA). More generally, we also wish to examine the benefit of TEA for the nonlinear case: Table 3 summarizes analogous results where component functions are implemented with GRU networks; results are shown for all datasets. Ceteris paribus, we observe that target-representation learning has a notable positive impact on performance. Interestingly, learning representations of inputs does not yield significant benefit, and the hybrid approach (F/TEA) is worse than TEA; this suggests that forcing intermediate representation to encode both features and targets may be overly constraining. (Note that for the linear model, the instances are restricted to those for which the full input window is available; as a consequence, the results for linear and nonlinear cases are not directly comparable). Figures 4 (Appendix C) and 5 (Appendix D) give training diagrams for all comparators. Additional experiment results (by model, timestep, metric) are in Appendix E.1-2.\nSource of Gain. There are two (related) interpretations of TEAs. First, we studied the regularization view in Section 3; this concerns the benefit of joint training using both prediction and reconstruction losses. Ceteris paribus, we expect performance to improve purely by dint of the jointly trained TEA objective. Second, the reduction view says that TEAs decompose the (difficult) prediction problem into two (smaller) tasks: the autoencoder learns a compact representation z of y, and the predictor learns to map x to z. This makes the potential benefit of staged training (Section 2 and Appendix C) intuitively clear, and suggests an alternative-that of simply training the autoencoder and predictor arms in two stages-\u00e0 la Mostajabi et al. (2018) . As a general framework, TEAs is a combination of both ideas: all three components are jointly trained in a third stage-\u00e0 la Girdhar et al. (2016) . We now account for the improvement in performance due to these two sources of benefit; Table 4 does so for the linear case (on UKCF), and Table 5 for the more general nonlinear case (on all datasets). The \"No Joint\" setting isolates the benefit from staged training only. This is analogous to basic unsupervised pretraining (though using targets), and corresponds to omitting the final joint training stage in Algorithm 1. The \"No Staged\" setting isolates the benefit from joint training only (without pretraining the autoencoder or predictor), and corresponds to omitting the first two training stages in Algorithm 1. The \"Neither\" setting is equivalent to vanilla prediction (REG) without leveraging either of the advantages. We observe that while both sources of benefit are individually important, neither setting performs quite as well as when both are combined. See Appendix E.1-2 for extended results. Variations. Having established the utility of target-embedding, we can ask whether variations on the same theme perform similarly. In particular, the embeddings in the empirical studies of Girdhar et al. (2016) and Yeh et al. (2017) are jointly learned via the reconstruction loss r and latent loss z -that is, the prediction arm continues to regress learned embeddings during the joint training stage (Figure 4(d) , in Appendix D). The principle is similar, although (as noted in Section 4) the primary task is therefore learned indirectly; this is in contrast to the vanilla TEA setup, where the primary task is learned directly via the prediction loss p . Tables 4 and 5 also compare the performance of vanilla TEAs with this indirect variant (TEA(L)), as well as a hybrid variant (TEA(LP)) for which both latent and prediction losses are trained jointly with the reconstruction loss ( Figure 4 (e). Perhaps as expected, we observe that performance across all three variants are more or less identical, affirming the general benefit of target-representation learning. Again, see Appendix E.1-2 for extended results."}, {"section_title": "SENSITIVITIES", "text": "Regularization. Of course, target-representation learning is not a replacement for other regularization strategies; it is an additional tool that can be used in parallel where appropriate. Figure 3 (a) shows the performance of TEA and REG with various coefficients \u03bd on 2 -regularization. By itself, introducing 2 -regularization does improve performance up to a certain point, beyond which the additional shrinkage bias incurred begins to be counterproductive; this is not surprising. Interestingly, introducing target-representation learning appears to leverage an orthogonal bias: it consistently improves prediction performance regardless of level of shrinkage. This is a practical result of the theoretical observation in Remark 3: while prior works obtain stability through explicit 2 -regularization, the benefit from target-embedding relies on a different bias entirely, which allows us to combine them. While increasing the strength of either form of regularization reduces variability in results (see also below), excessive bias of either alone degrades performance. See Appendix E.3 for full results.\nStrength of Prior. Target-embedding attempts to leverage the assumption that there exist compact and predictable representations of targets. Realistically (e.g. due to measurement noise), of course, this will not hold perfectly. In our experiments, we set the ratio of prediction and reconstruction losses to be 1 : 1 for TEA (as well as FEA and F/TEA); that is, the \"strength-of-prior\" coefficient \u03bb on r is 0.5. In order to isolate the effect of \u03bb during joint training, we observe the performance of TEAs with joint training only (i.e. removing the confounding effect of staged training). For large values of \u03bb, we expect the reconstruction task to dominate in priority, which is (under an imperfect prior) not beneficial for the ultimate prediction task-in general, a hidden representation that is most reconstructive is not necessarily also what is most predictable). For small values of \u03bb, the setup begins to resemble direct prediction. Figure 3 (b) verifies our intuition. Note that in the extreme case of \u03bb = 1, predictions are no better than random (see ROC\u223c 0.5). See Appendix E.3 for full results. Sample Complexity. Figure 3 (c) shows the performance of TEA and REG under various levels of data scarcity. The benefit conferred by TEAs is significant especially when the amount of training data N is limited. Importantly, note that we are operating strictly within the context of supervised learning: unlike in semi-supervised settings, here we are not just restricting access to paired data; we are restricting access to data per se. (Though beyond the scope of this paper, we expect that extending TEAs to semi-supervised learning with additional unpaired data would yield larger gains).\nHere, without the luxury of learning from unpaired data, we highlight the comparative advantage purely from the addition of target-representation learning. Again, see Appendix E.3 for full results."}, {"section_title": "DISCUSSION", "text": "By way of conclusion, we emphasize the importance of our central assumption: that there exist compact and predictable representations of the (high-dimensional) targets. This is critical: targetembedding is not useful where this is not true. Now obviously, learning representations of targets is unnecessary if the output dimension is trivially small (e.g. if the target is a single classification label), or if the problem itself is trivially easy (e.g. if direct prediction is already perfect). Also obvious is the situation where representations cannot possibly be compact (e.g. if all output dimensions are independent of each other), in which case any model with a compressive (bottleneck) representation as an intermediate target may make little sense to begin with. Perhaps less obvious is that we cannot assume that the goals of prediction and reconstruction are always aligned. Just as in learning featureembeddings (for downstream classification), what is most reconstructive may not necessarily encode what is most discriminative; so too in learning target-embeddings (for upstream prediction), what is most reconstructive may not necessarily encode what is most predictable. In the case of disease trajectories, it is medical knowledge that permits this assumption with some confidence. Appendix E.4 gives an extreme (synthetic) counterexample where this prior is outright false-i.e. prediction and reconstruction are directly at odds. While certainly contrived, it serves as a caveat about assumptions.\nUsing the deliberately challenging setting of disease trajectory forecasting with limited information, we have illustrated the nontrivial utility of target-representation learning in a controlled setting with baseline models. While we appreciate that component models in the wild may be more tailored, this setting better allows us to identify and isolate the potential utility of target-autoencoding per se. In addition to verifying our intuitions for the linear case, we have extended empirical validation of target-autoencoding to (nonlinear) sequence-to-sequence recurrent architectures; along the way, we explored the sources of gain from joint and staged training, as well as various sensitivities of interest. Where the prior holds, target-embedding autoencoders are potentially applicable to any high-dimensional prediction task beyond static classification and imaging applications, and exploring its utility for other specific domain-architectures may be a practical direction for future research. \nAdditivity and non-negativity are easy to see; that is, D (h h) \u2265 0 for any h, h \u2208 H, and if = 1 + 2 and both 1 and 2 are convex functions, then\nTheorem 1 (Uniform Stability) Let p and r be \u03c3 p -admissible and \u03c3 r -admissible loss functions, and let r be c-strongly convex. Then under Assumptions 1 and 2, the following inequality holds,\nProof. The overall strategy consists of three steps in sequence. First, we want to bound the delta in prediction loss under \u0398 * and \u0398 * using the set of representative vectors B. Second, we bound the resulting expression in terms of the Bregman divergence of the complete loss functions L and L under \u0398 * and \u0398 * . Third, we express the divergence back in terms of the original expression itself (consisting of representative vectors), which allows us to solve for a bound on that expression. Finally, combining the results from the three steps completes the proof. We begin with the left-hand term,\nwhere the first inequality follows from the fact that p is \u03c3 p -admissible, the equality follows from Assumption 1 for some coefficients \u03b1 m \u2208 R, and the second inequality follows from the Cauchy-Schwarz inequality. As our second step, the goal is to upper-bound the term under the square-root,\nwhere the first inequality follows from the fact that r is c-strongly convex, and the final equality follows from the definition of Bregman divergence (the standalone loss terms cancel). We want an expression in terms of the loss functions L and L , which will subsequently allow us to obtain a bound expressed back in terms of the set of representative vectors. Focusing on the term in the brackets,\nwhere the first and last equalities follows from the definition of Bregman divergence, and the second equality from the definition of directional derivatives. The first inequality follows from Assumption 2; for the second inequality, note that L r consists of a strict subset of the set of strictly convex losses that L consists of, and similarly for L . Therefore by additivity and non-negativity of the Bregman distance, we have that\n. Our third and final step is to go back and bound this term again using the set of representative vectors,\nwhere for first equality note that by construction the gradients of the losses L and L are zero at the respective optimal models \u0398 * and \u0398 * . The first inequality follows from the fact that p and r are \u03c3 p -admissible and \u03c3 r -admissible respectively, and the second inequality follows from Assumption 1 and the Cauchy-Schwarz inequality. Now, combining Equations 4, 5, and 6 allows us to write\nwhich-by substitution into Equation 3-completes the proof.\nRemark 4 Formulating the autoencoding component as an auxiliary task allows us to unambiguously interpret its benefit as a regularizer. Specifically, the complete loss can be summarized and rewritten as L(\u0398) = L p (\u0398) + R 1 (\u0398) + R 2 (\u0398); that is, the TEA objective is a combination of the primary prediction loss\nIn particular, the proof of Theorem 1 relies on R 1 (\u0398) to upper-bound instability (Appendix A). This precisely identifies the regularizer in question, while Theorem 1 quantifies its generalization benefit.\nRemark 5 Technicality: Moving from uniform stability (Theorem 1) to generalization bounds (Corollary 1) requires that the loss function not take on arbitrarily large values (see e.g. Bousquet & Elisseeff (2002) ). In practice, the label space itself is often bounded (see e.g. Assumption 1 in Le et al. (2018) ); then the problem effectively reduces to that with a bounded loss function. For example, consider a regression setting using the quadratic loss function, where the target data lie within [\u2212U, U ]; then the loss function is bounded to be within [0, 4U 2 ]. See Castro & Nowak (2018) .\nRemark 6 Technicality: Earlier we assumed \u03b5 = 0 for ease of exposition; carrying around the extra O(\u03b5) term (from Equations 3 and 6) is not particularly illuminating. Generalizing to \u03b5 = 0 can be done in a similar manner to Le et al. (2018) , with the additional assumptions of bounded spaces and that \u03b5 decreases as 1/N (which they note is reasonable, since the more samples in the data, the more likely the cross-representativity assumption will hold with low error). Again, note that \u03b5 = 0 holds as long as the number of independent latent vectors is at least |Z|). Similarly, Liu et al. (2016) consider \u03b5 = 0, noting in any case that they can increase N to obtain a small \u03b7 2 ; see their analysis for detail."}, {"section_title": "B EXPANDED RELATED WORK", "text": "In this paper, we motivate and analyze a general autoencoder-based target-representation learning technique in the supervised setting, quantifying the generalization benefit via an argument from uniform stability, as well as verifying its practical utility. As such, our work lies at the intersection of three threads of research: (1) supervised representation learning using autoencoders, (2) label space reduction for multi-label classification, as well as (3) algorithmic Although less studied, more closely related to our work is the use of autoencoders in a purely supervised setting: rather than focusing on how specific architectural novelties may better structure unlabeled data, Le et al. (2018) instead study the generalization benefit by the simple addition of reconstruction to the supervised classification task-a special case of what we describe as FEAs. Now, all aforementioned studies operate on the basis of autoencoding features (for an explicit or implicit downstream prediction task). In this paper, we instead focus on autoencoder-based target-representation learning (using TEAs) in the supervised setting, and-importantly-analyze the theoretical and empirical benefits of the approach. Unlike in simple classification (for which FEAs make sense), we are motivated by problems with high-dimensional output spaces, but where we operate under the assumption of a more compact and predictable set of underlying factors.\nWe take inspiration from the empirical investigation of Girdhar et al. (2016) , where latent representations of 3D objects (targets) are jointly trained to be predictable from 2D images (features); Our work is related to this general autoencoder approach to label-embedding, although there are significant differences in focus. In particular, we operate at a higher level of abstraction. Labelembedding techniques worry about label reduction, and about specific loss functions that aim to preserve dependencies within and among spaces; their problem is one of multi-label classification, and their baseline is binary relevance. In contrast, we worry about autoencoding at all-that is, we focus on the regularizing effect of the reconstruction loss on learning the prediction model; our baseline is direct prediction, and the output can be of any form ( 2014), our bound does not rely on explicit norm-based regularization-instead, we interpret the embedding task itself as an intrinsic form of regularization to derive our stability-based guarantee.\nFinally, also worth mentioning is the field of extreme multi-label classification (Bhatia et al., 2015) , for which probabilistic methods such as Rai et al. (2015) "}, {"section_title": "B.3 Algorithmic Stability and Learning Guarantees", "text": "Generalizability is central to machine learning, and its analysis via hypothesis stability is first studied in Rogers & Wagner (1978) and Devroye & Wagner (1979) . Unlike arguments based on the complexity of the search space (Vapnik & Chervonenkis, 1971; Pollard, 1984; Koltchinskii, 2001) , stability-based approaches account for how the model produced by the algorithm depends on the data. Epstein & Meir (2019) adapt recent margin, norm, and compression-based results for deep networks (Bartlett et al., 2017; Neyshabur et al., 2017; Arora et al., 2018) , and relate generalization of feature reconstructions to the benefit of additional unlabeled features for the primary classification task.\nIn the context of supervised problems, Mohri et al. (2015) and Gottlieb et al. (2016) analyze the generalization properties of dimensionality reduction techniques for features with respect to a downstream task; however, rather than joint training, the primary task is optimized subsequently over the learned representations. Taking a joint, multi-task approach (Caruana, 1997), Baxter (2000) first leverages the inductive bias of a common optimal hypothesis class to obtain a VC-based generalization bound. Maurer (2006) and Maurer et al. (2016) argue from Rademacher complexity to illustrate the benefit of the common operator; however, they only consider the task-averaged benefit, whereas we want to focus specifically on the primary task. There has been some work on generalization for each task (Ben-David & Schuller, 2003) , but limited to binary classification-contrary to our setting.\nArguing from stability, our approach is related to Liu et al. (2016) in showing that the algorithm for learning the shared model in a multi-task setting is uniformly stable. Our analysis also resembles Le et al. (2018) in the more specific setting where the bound for the primary prediction task is obtained with assistance from the auxiliary reconstruction loss; unlike Liu et al. (2016), we are not interested in a generic bound for all tasks. Again, however, the fundamental (and motivating) difference of our work stems from the (inverted) problem setting and resulting framework. In the vast majority of works, the primary task is one of classification (or more generally |X | |Y|), where featureembeddings make sense to learn. Instead, we attend to the setting in which Y is high-dimensional (but where the underlying factors are assumed to be compact). In this setting, we argue (theoretically and empirically) that target-embeddings make more sense to learn in an auxiliary reconstruction task."}, {"section_title": "C EXPANDED ALGORITHM DETAIL", "text": "In the following, Algorithm 1 gives pseudocode for TEA training. Figure 4 gives detailed block diagrams of component functions and objectives corresponding to each training stage (and variant "}, {"section_title": "Y", "text": "< l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1ef9 = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`z @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`z @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\n< l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 X < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y = \u2713(\u1e91; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = u(x; W u ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >\u1ef9 = \u2713(z; \u21e5) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z = e(y; W e ) < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > 2 Y < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`r @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > r < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > (e) Training (Stage 3), TEA(LP) @`z @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`z @W e < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > z < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @\u21e5 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > @`p @W u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t >"}, {"section_title": "D ADDITIONAL EXPERIMENT DETAIL", "text": "The UK Cystic Fibrosis registry records follow-up trajectories for over 10,000 patients over the period from 2008 and 2015 with a total of over 60,000 hospital visits. Each patient is associated with 90 variables over time, which includes data on treatments and diagnoses for 23 possible comorbidities (e.g. ABPA, diabetes, hypertension, pancreatitis), 11 possible infections (e.g. aspergillus, burkholderia cepacia, klebsiella pneumoniae), as well as static demographic information (e.g. gender, genetics, smoking status). Using both static and temporal information in a precedent window, we forecast the future trajectories for the diagnoses of infections and comorbidities (all binary variables) recorded at each follow-up. The Alzheimer's Disease Neuroimaging Initiative study tracks disease progression for over 1,700 patients over the period from 2004 to 2016 with a total of over 10,000 (bi-annual)"}, {"section_title": "E ADDITIONAL EXPERIMENT RESULTS", "text": ""}, {"section_title": "E.1 Results for Linear Models", "text": "Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. 0.463 \u00b1 0.011* 3 0.395 \u00b1 0.019* 0.400 \u00b1 0.013* 0.395 \u00b1 0.020* 0.457 \u00b1 0.010 0.437 \u00b1 0.013* 4 0.380 \u00b1 0.017* 0.385 \u00b1 0.010* 0.380 \u00b1 0.017* 0.434 \u00b1 0.007 0.417 \u00b1 0.013* PRC(C) 1 0.561 \u00b1 0.056* 0.592 \u00b1 0.029* 0.598 \u00b1 0.029* 0.695 \u00b1 0.010 0.685 \u00b1 0.015 2 0.504 \u00b1 0.039* 0.523 \u00b1 0.022* 0.527 \u00b1 0.021* 0.591 \u00b1 0.014 0.584 \u00b1 0.018 3 0.471 \u00b1 0.028* 0.488 \u00b1 0.018* 0.489 \u00b1 0.017* 0.537 \u00b1 0.007 0.530 \u00b1 0.017 4 0.453 \u00b1 0.023* 0.469 \u00b1 0.017* 0.470 \u00b1 0.016* 0.510 \u00b1 0.007 0.504 \u00b1 0.015 ROC(I) 1 0.788 \u00b1 0.018* 0.791 \u00b1 0.009* 0.794 \u00b1 0.014* 0.827 \u00b1 0.007 0.818 \u00b1 0.006* 2 0.753 \u00b1 0.015* 0.757 \u00b1 0.011* 0.758 \u00b1 0.017* 0.783 \u00b1 0.008 0.778 \u00b1 0.009 3 0.736 \u00b1 0.013* 0.741 \u00b1 0.012* 0.740 \u00b1 0.016* 0.760 \u00b1 0.007 0.757 \u00b1 0.010 4 0.725 \u00b1 0.012* 0.731 \u00b1 0.011* 0.727 \u00b1 0.014* 0.748 \u00b1 0.008 0.744 \u00b1 0.010 ROC(C) 1 0.794 \u00b1 0.022* 0.809 \u00b1 0.015* 0.808 \u00b1 0.012* 0.838 \u00b1 0.007 0.834 \u00b1 0.007 2 0.750 \u00b1 0.017* 0.761 \u00b1 0.010* 0.761 \u00b1 0.009* 0.782 \u00b1 0.007 0.781 \u00b1 0.008 3 0.723 \u00b1 0.013* 0.733 \u00b1 0.007* 0.735 \u00b1 0.010* 0.752 \u00b1 0.006 0.751 \u00b1 0.009 4 0.699 \u00b1 0.009* 0.709 \u00b1 0.009* 0.711 \u00b1 0.010* 0.726 \u00b1 0.006 0.724 \u00b1 0.008 PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result. Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. MSE evaluations reported separately for targets representing quantitative biomarkers (B) and cognitive tests (C). The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining). MSE evaluations reported separately for targets representing quantitative biomarkers (B) and cognitive tests (C). The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining)."}, {"section_title": "E.2 Results for Recurrent Models", "text": "Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result. The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result.\nResults are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining). The \"No Joint\" setting isolates the benefit from staged training only (analogous to basic unsupervised pretraining, though using targets); the \"No Staged\" setting isolates the benefit from joint training only (without pretraining).\nResults are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. The \u03bd coefficient controls the strength of 2-regularization applied on top of the original loss function minimized. PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C)."}, {"section_title": "E.3 Results for Sensitivities", "text": "Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. \u03c4 \u03bb = 0 \u03bb = 0.01 \u03bb = 0.1 \u03bb = 0.5 \u03bb = 0.9 \u03bb = 0.99 \u03bb = 1 PRC(I) 1 0.370 \u00b1 0.101 0.383 \u00b1 0.106 0.412 \u00b1 0.091 0.472 \u00b1 0.016 0.461 \u00b1 0.012 0.327 \u00b1 0.011 0.150 \u00b1 0.008 2 0.350 \u00b1 0.085 0.361 \u00b1 0.090 0.386 \u00b1 0.076 0.439 \u00b1 0.016 0.431 \u00b1 0.012 0.323 \u00b1 0.011 0.162 \u00b1 0.008 3 0.337 \u00b1 0.076 0.347 \u00b1 0.081 0.368 \u00b1 0.068 0.415 \u00b1 0.015 0.410 \u00b1 0.009 0.316 \u00b1 0.012 0.168 \u00b1 0.007 4 0.328 \u00b1 0.071 0.337 \u00b1 0.075 0.357 \u00b1 0.064 0.399 \u00b1 0.011 0.395 \u00b1 0.008 0.307 \u00b1 0.011 0.170 \u00b1 0.007 PRC(C) 1 0.467 \u00b1 0.106 0.481 \u00b1 0.110 0.528 \u00b1 0.104 0.620 \u00b1 0.030 0.620 \u00b1 0.016 0.433 \u00b1 0.012 0.236 \u00b1 0.012 2 0.435 \u00b1 0.081 0.445 \u00b1 0.084 0.481 \u00b1 0.079 0.550 \u00b1 0.022 0.553 \u00b1 0.013 0.427 \u00b1 0.010 0.249 \u00b1 0.010 3 0.418 \u00b1 0.067 0.427 \u00b1 0.070 0.456 \u00b1 0.064 0.512 \u00b1 0.017 0.516 \u00b1 0.009 0.421 \u00b1 0.009 0.259 \u00b1 0.011 4 0.412 \u00b1 0.060 0.420 \u00b1 0.062 0.445 \u00b1 0.057 0.491 \u00b1 0.015 0.494 \u00b1 0.009 0.415 \u00b1 0.009 0.266 \u00b1 0.011 ROC(I) 1 0.737 \u00b1 0.081 0.742 \u00b1 0.089 0.764 \u00b1 0.067 0.799 \u00b1 0.007 0.791 \u00b1 0.004 0.708 \u00b1 0.008 0.499 \u00b1 0.013 2 0.709 \u00b1 0.070 0.713 \u00b1 0.077 0.733 \u00b1 0.058 0.765 \u00b1 0.009 0.760 \u00b1 0.008 0.694 \u00b1 0.007 0.502 \u00b1 0.014 3 0.697 \u00b1 0.065 0.701 \u00b1 0.071 0.719 \u00b1 0.054 0.750 \u00b1 0.008 0.746 \u00b1 0.008 0.690 \u00b1 0.006 0.500 \u00b1 0.014 4 0.696 \u00b1 0.063 0.699 \u00b1 0.068 0.715 \u00b1 0.053 0.744 \u00b1 0.005 0.741 \u00b1 0.006 0.690 \u00b1 0.007 0.501 \u00b1 0.015 ROC(C) 1 0.741 \u00b1 0.088 0.747 \u00b1 0.092 0.775 \u00b1 0.075 0.821 \u00b1 0.011 0.819 \u00b1 0.006 0.725 \u00b1 0.014 0.493 \u00b1 0.034 2 0.707 \u00b1 0.072 0.712 \u00b1 0.076 0.735 \u00b1 0.061 0.774 \u00b1 0.009 0.774 \u00b1 0.007 0.704 \u00b1 0.012 0.496 \u00b1 0.027 3 0.686 \u00b1 0.061 0.691 \u00b1 0.067 0.711 \u00b1 0.052 0.746 \u00b1 0.007 0.745 \u00b1 0.003 0.690 \u00b1 0.011 0.497 \u00b1 0.028 4 0.667 \u00b1 0.056 0.672 \u00b1 0.059 0.689 \u00b1 0.048 0.722 \u00b1 0.007 0.721 \u00b1 0.005 0.675 \u00b1 0.014 0.497 \u00b1 0.025\nThe \u03bb coefficient controls the strength of prior-i.e. the tradeoff between the prediction and reconstruction loss. PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The \u03bb coefficient controls the strength of prior-i.e. the tradeoff between the prediction and reconstruction loss. PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). Results are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping. \nHere with give a contrived example where the goals of prediction and reconstruction are directly at odds with each other. Specifically, we show a setup where the \"and\" part of \"compact and predictable\" representations is impossible-that is, a compact target-representation that is more reconstructive ends up being less predictable. Consider the following (true) data generating process: Latent variables p, u each consist of 10 independent dimensions, where p i \u223c N (0, 1) and u i \u223c N (0, 1). Feature vectors x are also of length 10, and are linear in p. Target vectors y = [y P , y U ] are of length 50, where y P is of length 10 and linear in p and y U is of length 40 and linear in u. See Figure 7 . Note that the input features are inadequate for predicting all targets; our choice of lettering denotes elements that are in principle predictable (\"P\"), and those that are in principle unpredictable (\"U\").\nx < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y U < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > y P < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > dim = 40 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > dim = 10 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > dim = 10 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > dim = 10 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > dim = 10 < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > p < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > u < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > < l a t e x i t s h a 1 _ b a s e 6 4 = \" ( n u l l ) \" > ( n u l l ) < / l a t e x i t > Figure 6 : Data generating process for synthetic example. Latent vectors p, u linearly generate feature vectors\nx and target vectors y. In this situation, yP is in principle predictable from x, while yU is impossible to predict.\nSuppose this data generating process is unknown to us. First, consider what happens with direct prediction: A linear model would learn to predict y P well, while predictions of y U would be no better than random. So far, so good. Now given the feature and target dimensions, consider the (not unreasonable) choice of TEAs with a latent dimension of 10. This is an obvious problem: During reconstruction, we naturally get more bang for our buck by encoding more of the (highly compressible) y U instead of y P ; yet y U is entirely useless to encode, as it is not predictable from inputs anyway. Reconstructing well is therefore directly at odds with predicting well. This is certainly an extremely contrived scenario; nevertheless, without sufficient domain knowledge, it serves as a caveat that-as with feature-embedding paradigms-target-embedding is only as good as its assumptions. Figure 7 : Synthetic scenario where prediction is directly at odds with reconstruction. The prior (that we can leverage compact and predictable representations of targets) is hugely incorrect in this case; as a result, not only is target-autoencoding not beneficial-it is positively harmful. For TEAs, we observe that as the strength-of-prior coefficient \u03bb increases, the overall prediction error actually increases (while the reconstruction error decreases). "}, {"section_title": "MSE(P)", "text": "0.000 \u00b1 0.000 0.000 \u00b1 0.000 0.000 \u00b1 0.000 0.087 \u00b1 0.028 0.061 \u00b1 0.022 MSE metrics are further reported separately for targets that are in principle predictable (P) and unpredictable (U). 0.000 \u00b1 0.000 0.003 \u00b1 0.005 0.022 \u00b1 0.009 0.087 \u00b1 0.028 0.125 \u00b1 0.063 MSE metrics are further reported separately for targets that are in principle predictable (P) and unpredictable (U)."}, {"section_title": "E.5 Results from Open Discussion", "text": "One can also ask the (purely empirical) question of how much each model degrades on out-ofdistribution data-without additional training to fine-tune the model to the new data. In this context, we actually have no reason to expect TEAs to degrade any more or less than comparators. For thoroughness, we show an additional experiment as an example for sensitivity analysis (using UKCF) as follows: Each model is trained (only) on male patients and tested (only) on female patients, and vice versa. The average results on held-out samples from in-distribution data and out-of-distribution data then allow us to compute the net degradation (i.e. negative difference), which is reported below. While TEAs individually perform better overall on both in-distribution and out-of-distribution samples, none of the differences in the amounts of degradation between models are statistically significant: 0.025 \u00b1 0.015 0.029 \u00b1 0.015 0.024 \u00b1 0.014 0.013 \u00b1 0.020 0.019 \u00b1 0.018 PRC(I) 0.022 \u00b1 0.020 0.018 \u00b1 0.021 0.021 \u00b1 0.022 0.033 \u00b1 0.022 0.027 \u00b1 0.022 PRC(C) 0.026 \u00b1 0.021 0.029 \u00b1 0.018 0.026 \u00b1 0.019 0.018 \u00b1 0.023 0.021 \u00b1 0.019 PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result.\nResults are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping.\nFinally, given the staged training in Algorithm 1, it should be clear that the order cannot be changed. Stage 2 requires the encoder to already be trained to provide the requisite embeddings, so it must be preceded by Stage 1. Therefore the only relevant possibilities are: (1) Stages 1-2 by themselves, without Stage 3; this is simply the \"No Joint\" setting.\n(2) Stage 3 by itself, without Stages 1-2; this is simply the \"No Staged\" setting.\n(3) None of the stages altogether; this is simply the \"Neither\" setting.\n(4) Stages 1, 2, and 3 in order; this is simply Algorithm 1 itself. The only remaining possibility is to have Stage 3 precede Stages 1-2. This makes little sense, since when the reconstruction loss is trained by itself it is likely to \"undo\" the result of joint training. For thoroughness, we run an additional sensitivity experiment (using UKCF) to confirm this. The following corresponds to the left half of Table 4 , with the additional column on the right (and the other columns labeled to reflect the training stages). Verifying our intuitions, the setting \"3-1-2\" behaves almost identically to the setting \"1-2\": PRC and ROC evaluations are reported separately for targets representing infections (I) and comorbidities (C). The two-sample t-test for a difference in means is conducted on the results. An asterisk next to the comparator result is used to indicate a statistically significant difference in means (p-value < 0.05) relative to the TEA result.\nResults are grouped over the temporal axis; note that the variance between splits is an artifact of this grouping."}]