[{"section_title": "Abstract", "text": "Deep learning methods have shown great success in pixel-wise prediction tasks. One of the most popular methods employs an encoder-decoder network in which deconvolutional layers are used for up-sampling feature maps. However, a key limitation of the deconvolutional layer is that it suffers from the checkerboard artifact problem, which harms the prediction accuracy. This is caused by the independency among adjacent pixels on the output feature maps. Previous work only solved the checkerboard artifact issue of deconvolutional layers in the 2D space. Since the number of intermediate feature maps needed to generate a deconvolutional layer grows exponentially with dimensionality, it is more challenging to solve this issue in higher dimensions. In this work, we propose the voxel deconvolutional layer (VoxelDCL) to solve the checkerboard artifact problem of deconvolutional layers in 3D space. We also provide an efficient approach to implement VoxelDCL. To demonstrate the effectiveness of VoxelDCL, we build four variations of voxel deconvolutional networks (VoxelDCN) based on the U-Net architecture with VoxelDCL. We apply our networks to address volumetric brain images labeling tasks using the ADNI and LONI LPBA40 datasets. The experimental results show that the proposed iVoxelDCNa achieves improved performance in all experiments. It reaches 83.34% in terms of dice ratio on the ADNI dataset and 79.12% on the LONI LPBA40 dataset, which increases 1.39% and 2.21% respectively compared with the baseline. In addition, all the variations of VoxelDCN we proposed outperform the baseline methods on the above datasets, which demonstrates the effectiveness of our methods."}, {"section_title": "INTRODUCTION", "text": "In recent years, deep learning methods play an important role in various computer vision tasks such as image classification [14] , data completion [17] , action recognition [12] and pixel-wise prediction [4, 11, 26] . Some key network layers like convolutional layers [15] , pooling/unpooling layers [21, 34] , deconvolutional layers [28] and some well-known models like generative models [9] and encoder-decoder architectures [21, 23] are frequently used for these tasks. In pixel-wise prediction tasks, U-Net [23] with an encoder-decoder architecture is commonly used. The encoder path contains convolutional and down-sampling operations to extract high-level feature maps from raw images, while the decoder path recovers feature maps to the original spatial size using up-sampling operations. The architecture of an encoder is very similar to a classic convolutional neural networks which have been studied extensively [16, 23] . On the other hand, less attention is paid to the decoder path. There are three primary ways to up-sample feature maps; namely deconvolution, unpooling and resampling with interpolation [2] . In practice, deconvolutional layers are the most commonly used. However, a key problem with the deconvolutional layer is the presence of the checkerboard artifact issue [1, 22] , which is caused by the independence among the adjacent pixels on the output feature maps.\nTo solve the checkerboard artifact problem, some studies focused on improving the post-processing [5] , which made the whole process not fully trainable. Some other work focused on adding smooth constraints [13] , which resulted in a more complex process. In contrast, the pixel deconvolutional networks [7] solved the checkerboard artifact problem by generating the intermediate feature maps sequentially, thereby building direct relationships among adjacent pixels on output feature maps. This is an effective way while keeping the learning process trainable. However, it only solved this issue in 2D deconvolutional layers. The checkerboard artifact issue also exists in 3D deconvolutional layers, and it is more challenging due to the fact that the number of intermediate maps needed to generate one deconvolutional layer grows exponentially with dimensionality. There are a total of 2 d intermediate feature maps needed when generating a deconvolutional layer given a d dimensional input.\nIn this paper, we propose the voxel deconvolutional layer (VoxelDCL) to address the checkerboard artifact of 3D deconvolutional layers. We build four variations of VoxelDCLs, which are known as iVoxelDCLc, iVoxelDCLa, VoxelDCLc, and VoxelDCLa, based on different approaches when generating the intermediate feature maps. The iVoxelDCLc and iVoxelDCLa use the input along with the generated intermediate feature maps to generate new intermediate feature maps by concatenation and addition, respectively. The VoxelDCLc and VoxelDCLa only use the generated intermediate feature maps to generate new intermediate feature maps. We also provide an efficient implementation method to improve the computational efficiency by reducing unnecessary dependencies among the intermediate feature maps. To demonstrate the effectiveness of the proposed VoxelDCL, we build the voxel deconvolutional networks (VoxelDCN) based on the U-Net with four variations of VoxelDCL and apply them to the volumetric brain image labeling task [6, 29, 31, 33, 37] using the Alzheimer's disease neuroimaging initiative (ADNI) [20] and the LONI LPBA40 [25] datasets. The results show that our methods outperform the U-Net with regular deconvolutional layers significantly in terms of dice ratio. Specifically, the iVoxelDCLa achieves the best performance on both the ADNI and LONI LPBA40 datasets with 83.34% and 79.12% dice ratio, respectively."}, {"section_title": "RELATED WORK 2.1 Deep Learning for Pixel-Wise Prediction", "text": "In computer vision, many problems can be formulated as assigning a label to every pixel of an image, such as semantic segmentation [11, 21, 23, 26] . The goal of semantic segmentation is to label each pixel of the image so that pixels belonging to the same class get the same label. In recent years, convolutional neural networks (CNNs) have had great success in computer vision and brought great improvement in semantic segmentation tasks. The fully convolutional network (FCN) [26] can generate segmentation maps with an input image of any size. It is much faster and more effective than the traditional patch-wise classification methods [3] . Multiple encoder-decoder based architectures [16, 23] are also proposed. The encoder part reduces the spatial sizes with pooling layers and extracts high-level feature maps while the decoder part recovers them to the original spatial size. U-Net [23] is one of the most widely used networks in natural and medical image segmentation tasks."}, {"section_title": "Operations for Up-Sampling", "text": "To recover the spatial size of the extracted feature maps to the original size as the input image, up-sampling layers are essential in the decoder path of a dense prediction network. Unpooling, resampling with interpolation, and deconvolution are the most commonly used operations for up-sampling. Unpooling layers [21, 34] put each activation back to its original location based on the recorded location of maximum activation selected during the corresponding pooling operations. Up-sampling layers using resampling with interpolation [2] scales an feature map to the desired size and calculates the value of each pixel using an interpolation method such as bilinear interpolation. In the above two methods, there is no learning parameters required in the operation. The third method, known as the deconvolutional layer [1, 22, 28] , is the most popular method for up-sampling tasks. It up-samples feature maps by using operations that can be formulated as convolutional operations with learned kernels. More details are explained in Section 3.1. However, deconvolutional layers suffer from the checkerboard artifact issue. This is because there is no direct relationship among adjacent pixels on the output feature map. To solve this problem, pixel deconvolutional networks [7] "}, {"section_title": "3D Brain Image Labeling", "text": "3D brain image labeling is an important task since plenty of quantitative brain image analysis often relies on it. It becomes a popular topic in the medical image analysis field. In computer vision area, this task can be seen as a 3D semantic segmentation task [35, 38] . Some existing methods [8, 18, 24, 30, 32, 36] use multi-atlas based labeling models to predict the labels of new images. These methods first transfer the segmentation labels from pre-labeled atlases to a new image and then apply the label fusion method to combine the transferred labels as predicted results. There are also several learning-based labeling methods using random forests, support vector machine, and neural networks [19] to train a prediction model. Among these methods, neural networks have an unique advantage in that it does not require hand-crafted feature extraction in advance. It enables end-to-end learning, which improves efficiency of the training process. In this work, we introduce a novel deep neural network architecture and apply the variations of this network on the 3D brain image labeling task."}, {"section_title": "VOXEL DECONVOLUTIONAL NETWORKS", "text": "In this section, we introduce the concept of deconvolutional layers and other related operations, including transposed convolutional layers [28] and sub-pixel convolutional layers [1, 22, 28] . We show the equivalence among these concepts in the 1D case. After that, we describe 2D and 3D deconvolutional layers in the form of sub-pixel deconvolutional layer and show the checkerboard artifact that they suffer [22] . We discuss existing approaches to solve the checkerboard artifact and propose the voxel deconvolutional layers and networks, which can overcome the checkerboard problem of 3D deconvolutional layers. We show that our methods achieve better labeling performance on the Alzheimer's disease Neuroimaging Initiative (ADNI) [20] and the LONI LPBA40 [25] datasets as compared with other baseline methods. \nFigure 1: Illustration of a 1D deconvolutional layer. The green and yellow colors represent the odd and even columns of the kernel, respectively. \u2295 denotes the periodical shuffling and combination operation. y is the input andx is the output from the deconvolutional layer. By multiplying each column of the weight matrix C with y, we can obtain its corresponding outputx i (see (a)). Since all the odd columns ofx are computed only by w1 and w3 and all the even columns ofx are computed by w2 and w4, the operation can be decomposed into two convolutions with two independent kernels of sizes 1 \u00d7 2, resulting in kernel1 and kernel2. The intermediate results are then shuffled and combined to obtain the final outputx.x can be cropped by two pixels from both ends to make the up-sampling factor to be 2."}, {"section_title": "Deconvolutional Layer", "text": "Deconvolutional layers can be viewed as a form of convolutional layers. The relationship between convolutional and deconvolutional layers can be best understood when both of them are considered as fully connected layers. Specifically, convolutional layers can be considered as fully connected layers with sparse connection matrices. Let us consider the following example in 1D. Given an input vector x \u2208 R 8 , we pad the input by adding two zeros to both ends of x, yielding the padded inputx \u2208 R 12 . We then apply a 1D convolution with a stride of 2 and a kernel of size 4 to produce an output vector y \u2208 R 5 . This convolution operation can be equivalently viewed as a fully connected operation as\nwith a 5 \u00d7 12 sparse connection matrix C, defined as follows: \nIn this example, y can be cropped by one pixel from the right end to make the down-sampling factor to be 2.\nThe above example reduces x to a lower-dimension by a convolution of stride 2. A similar operation can be used to convert a lower-dimensional input to a high-dimensional output, resulting in the deconvolutional operation. Specifically, assume y is the input andx is the output, then their relationship can be expressed as\nwhere C is defined in Eq. (2). It can be seen from Eq. (3) that, given a lower-dimensional input, a higher-dimensional output can be obtained via a fully connected layer with a sparse connection matrix. This results in the so-called deconvolutional layer. Since deconvolution layers use the transposed weight matrix of its corresponding convolutional operation C, it is also known as transposed convolutions. Since C is a sparse matrix, another way to understand the deconvolutional layer is to interpret it as a standard convolution. Specifically, it can be considered as performing multiple independent convolutions on the input followed by a periodical shuffling operation [27] . An example is given in Figure 1 to illustrates this idea."}, {"section_title": "3D Deconvolutional Layer", "text": "In the previous section, we describe how to understand deconvolutional layers as a form of convolutional layers in 1D space. The same strategy can be used in 2D and 3D spaces as well. In 2D case, the first step is to generate 4 intermediate feature maps from padded input. This step simply requires 2D convolutional operations. Next, these feature maps are periodically shuffled and combined together to form the output. The same steps can be applied to perform deconvolutional operations in 3D space, which will be discussed next. Assume X \u2208 R l \u00d7m\u00d7n is the input and Y \u2208 R 2l \u00d72m\u00d72n is the output of a deconvolutional layer. Here the up-sampling factor is 2. We first perform eight 3D convolutional operations on the input. Each of such operation generates one intermediate feature map Y i with size l \u00d7 m \u00d7 n given by\nwhere \u2297 denotes the convolutional operation, Y i denotes the i t h feature map and k i denotes the corresponding kernel. We add padding to the input in order to make sure that spatial size remains the same. Finally, these 8 feature maps are periodically shuffled and combined together as\nwhere \u2295 denotes the periodical shuffling and combination operation, as illustrated in Figure 2 .\nCompared to deconvolutional layers in 2D space, the number of feature maps needed in 3D space grows exponentially. In general, assume the up-sampling factor is 2 and the dimensionality is d, the number of intermediate feature maps need to generate one deconvolutional layer is 2 d . This indicates that deconvolutional layers in higher dimensional space are much more complex and computationally expensive than those in lower dimensional space. These are factors to consider when we introduce voxel deconvolutional layers in Section 3.3."}, {"section_title": "Voxel Deconvolutional Layer", "text": "When we consider a deconvolutional layer as the shuffled combination of several intermediate feature maps, discontinuities among adjacent pixels can be observed frequently. This is not surprising since the adjacent pixels are coming from independent feature maps. This is the checkerboard artifact problem that all deconvolutional layers suffer, no matter calculated in 2D or 3D space.\nGao et al. [7] solved the checkerboard artifact of deconvolutional layers in 2D space by adding relations to the intermediate feature maps. Inspired by [7] , we propose the voxel deconvolutional layer to solve the same issue in 3D space. As we mentioned in Section 3.2, the computational cost and complexity of deconvolutional operations in 3D space are much higher than those in 2D space, thereby making this task challenging.\nBack to the example in Section 3.2, we use X \u2208 R l \u00d7m\u00d7n to denote the input and Y \u2208 R 2l \u00d72m\u00d72n to denote the output. The We first introduce the naming conventions of the proposed voxel deconvolutional layers and corresponding networks in below:\n\u2022 (6) where \u2297 denotes a convolutional operation, [\u00b7, \u00b7] represents the concatenation and k i denotes the corresponding convolutional kernel. By using concatenation, X , Y 1 , \u00b7 \u00b7 \u00b7 , Y i\u22121 are stacked as channels of a single input to generate Y i . There will be weights assigned to each of X , Y 1 , \u00b7 \u00b7 \u00b7 , Y i\u22121 , indicating their importance to Y i . However, concatenation will cause memory and computational issues due to the large amount of parameters needed. This problem can be reduced by using addition when combining multiple related feature maps as input, which will be denoted as iVoxelDCLa.\nIn iVoxelDCLa, the input X and intermediate feature maps\nare added together to form the input to generate Y i as\nIn iVoxelDCLc and iVoxelDCLa, the input X is included in the generation of every intermediate feature map. This might be redundant since the information carried in X will be carried over in Y 1 to Y 8 through this sequential process. In the next two versions of VoxelDCL, we take out the input X when generating Y 2 , \u00b7 \u00b7 \u00b7 , Y 8 . Only the first intermediate feature map Y 1 is generated using X. Similarly, we first use concatenation to combine multiple inputs, which will be denoted as VoxelDCLc. In VoxelDCLc, the intermediate feature maps Y 1 , Y 2 , \u00b7 \u00b7 \u00b7 , Y i\u22121 are concatenated together to form the input to generate Y i while Y 1 is generated from the input X :\nTo further reduce memory usage and computational complexity, we use addition instead of concatenation the same way as we described in iVoxelDCLa layer. This layer is known as VoxelDCLa. \nOnce all the eight intermediate feature maps are generated, we can obtain the final output using Eq. (5). In Figure 2 , we provide an example to illustrate how the VoxelDCLa and VoxelDCLc work."}, {"section_title": "Efficient Implementation", "text": "We propose an efficient way to implement all of the above voxel deconvolutional layers in order to scale down the computational cost. The goal is to reduce unnecessary dependencies among the intermediate feature maps. The basic principle is that, for voxels that are not adjacent to each other but linked to the same pivot voxel in the output, we generate their corresponding feature maps in parallel. In this way, we remove the dependency of unrelated inputs when generating new feature maps, hence simplifying the process and expediting the computation. In this new design, the intermediate feature maps are generated in 4 steps. Specifically, Y 1 , which denotes the 1 st intermediate feature map, is generated from the input X . Then Y 2 is generated from Y 1 . Since voxels from Y 3 , Y 4 , Y 5 are not adjacent to each other but are all linked to voxels from Y 1 , we generate them in parallel using previously generated Y 1 and Y 2 . The same strategy is used for generating Y 6 , Y 7 , Y 8 . They are generated in parallel from all the previously generated Y 1 , \u00b7 \u00b7 \u00b7 , Y 5 . In iVoxelDCLa and iVoxelDCLc, the input X is also included in each step. By using parallel generation in steps 3 and 4, the computational time for VoxelDCL is reduced. In this way, we build a reasonable relationship among these intermediate feature maps. Figure 3 illustrates how VoxelDCLa and VoxelDCLc work."}, {"section_title": "Overview of Network Architectures", "text": "U-Net [23] is a convolutional neural network architecture commonly used for dense prediction. It has an encoder path which extracts high-level feature maps from raw images and a decoder path which recovers feature maps to the original spatial size. In the classic U-Net architecture, there is repeated application of three convolutional layers, followed by a max pooling layer for downsampling in each encoder block. Batch normalization [10] is used after each convolutional layer. The number of channels is doubled after each down-sampling operation. In each decoder block, there is a deconvolutional layer followed by two convolutional layers. The output of the deconvolutional layers are concatenated with corresponding feature maps from encoder blocks before going to the next block. The proposed architecture in this work, which is denoted as voxel deconvolutional network (VoxelDCN), is based on this U-Net framework. But we replace the deconvolutional layers in the decoder path with voxel deconvolutional layers. So there are five architectures implemented for comparison:\n\u2022 U-Net: We use U-Net as our baseline method. It is a classic neural network architecture with encoder and decoder parts. It uses deconvolutional layers for up-sampling in decoder path.\n\u2022 iVoxelDCNc: In this method, we replace all deconvolutional layers in U-Net with iVoxelDCLc layers. Step 1 is to generate the 1 st feature map directly from the input.\nStep 2 is to generate the 2 nd feature map from the 1 st one. The 3 r d to 5 t h feature maps are generated from the 1 st and 2 nd feature maps in step 3. Finally, the last three feature maps are generated from all previous five feature maps in step 4. (b) shows how these eight intermediate feature maps are shuffled and combined to form the final 4 \u00d7 4 \u00d7 4 output. In VoxelDCLa layers, multiple feature maps are added together to form the input for the next feature map while in VoxelDCLc layers they are concatenated. Figure 4 : Network architecture implemented on the ADNI dataset. The encoder has two max pooling layers with sizes of 2\u00d72\u00d72. We replace the regular deconvolutional layers in UNet with variations of the proposed voxel deconvolutional layers in the decoder path."}, {"section_title": "3D input", "text": "\u2022 iVoxelDCNa: In this method, we replace all deconvolutional layers in U-Net with iVoxelDCLa layers.\n\u2022 VoxelDCNc: In this method, we replace all deconvolutional layers in U-Net with VoxelDCLc layers.\n\u2022 VoxelDCNa: In this method, we replace all deconvolutional layers in U-Net with VoxelDCLa layers. Figure 4 shows the architecture we implemented on the ADNI dataset. On the LONI LPBA40 dataset, we use a similar architecture with more blocks in both encoder and decoder paths to avoid underfitting problem."}, {"section_title": "EXPERIMENTAL STUDIES", "text": "In this section, we demonstrate the performance of our proposed methods on two public datasets that have been widely used for brain images labeling, namely the Alzheimer's disease neuroimaging initiative (ADNI) dataset [20] and the LONI LPBA40 dataset [25] . We select these two datasets since they represent different types of brain image labeling. The ADNI dataset has rich brain MR images for labeling hippocampal regions. It can be treated as a segmentation task with binary classes. On the contrary, the LONI LPBA40 dataset has various regions of interest, mostly inside the cortex of the brain. It can be treated as a multi-class segmentation task. Examples from these datasets are provided in Figure 5 . Our code is publicly available 1 .\nWe use classic U-Net as the baseline method to evaluate the performance of our proposed methods . Dice ratio is used to measure the labeling accuracy. It calculates the degree of overlap between the predicted area and its corresponding ground truth for each target class. It is defined by where A is the predicted result and B is the corresponding true label. For k different regions of interest (ROI), an averaged dice ratio is calculated, given by\nwhere A i represents the prediction for the i t h ROI and B i represents the corresponding ground truth label."}, {"section_title": "ADNI Dataset", "text": "The ADNI dataset is mostly used to label hippocampus in brains. The task is to determine whether a certain part of the brain is hippocampus or not. We consider it as a segmentation task with binary classes. Data Preparation: There are 64 samples in the ADNI dataset with sizes of 96 \u00d7 124 \u00d7 96. We randomly split the dataset into training data with 59 samples and testing data with 5 samples. We repeat this process for five times and build five segmentation models respectively. The averaged dice ratio is the reported performance of this experiment.\nExperimental Setup: We build the baseline model using U-Net architecture as shown in Figure 4 . The number of output channels in the first encoder block is 16. The convolutional kernel size is 3\u00d73\u00d73 and the stride size used in the max pooling layers is 2\u00d72\u00d72. The last convolutional operation in the final decoder block has 2 output channels, which corresponds to the total number of classes. We apply batch normalization after each convolutional layer, except for the output layer. The training batch size is 4. We implement Table 1 shows the overall dice ratios of the baseline method and the proposed methods. We can see that all the proposed methods have higher dice ratios than the baseline method. Model iVoxelDCNa achieves 83.34% in dice ratio, which improves the baseline method by 1.39%. The result demonstrates that the proposed methods, which intend to build relationships among intermediate feature maps, can help networks better capture local information of images than the baseline method."}, {"section_title": "LONI LPBA40 Dataset", "text": "The LONI LPBA40 dataset is designed as a multi-class labeling task. It requires 54 regions of interest to be labeled in brain images automatically.\nData Preparation There are 40 brain image samples with sizes of 220 \u00d7 220 \u00d7 220 in the dataset. Each image has 54 manually labeled ROIs along with cerebrum, brainstem, and background. When calculating result, only dice ratios of the 54 ROIs are included. Since we are not interested in predicting background, we first crop the image to drop the excessive background area around boundaries. The cropped image size is 180 \u00d7 145 \u00d7 137. Then we split the dataset into training set with 16 samples, validation set with 4 samples and testing set with the remaining 20 samples. We flip the images across all three directions on training and validation datasets. This increases the number of training samples to 128 and the number of validation samples to 32. The size of testing data remains 20 as we do not apply data augmentation on testing data.\nExperimental Setup: The architecture of U-Net implemented on this dataset consists of five blocks in both the encoder path and decoder path. The number of output channels in the first encoder block is 32. The convolutional kernel size is 3 \u00d7 3 \u00d7 3 and stride size used in the max pooling layers is 1 \u00d7 2 \u00d7 2. The last convolutional operation in the final decoder block has 57 output channels, which corresponds to the total number of classes (54 ROIs, cerebrum, brainstem and background). The training batch size is 1. Since each data sample provided is too large to be stored in memory, we use training patch with size of 128 \u00d7 128 \u00d7 32 as input in the training process. Each training patch are randomly cropped from training data. At the testing time, we pick one patch at a time from a single testing data sample with the same size in turn. The predicted patches are concatenated together with a linear weighted summation on overlapped part to get the final prediction results. We implement our models on Tensorflow and use AdamOptimizer to update the network with moment estimates \u03b21 = 0.9 and \u03b22 = 0.999."}, {"section_title": "Analysis of Results:", "text": "The dice ratio of ROIs in the left and the right hemispheres are provided in Figure 6 . Compared with the baseline method, iVoxelDCNa shows improvement in 44 out of 54 ROIs; VoxelDCNc shows improvement in 35 out of 54 ROIs; iVoxelDCNc shows improvement in 30 out of 54 ROIs; VoxelDCNa shows improvement in 29 of 54 ROIs. Table 1 shows the experimental results in terms of average dice ratio. All the proposed methods have better performance than the baseline model. Network iVoxelDCNa has the best performance and achieves 2.21% improvement compared with baseline. The result demonstrates that the proposed methods can help networks better capture the local information of images than the baseline method by eliminating the checkerboard artifact, yielding a better labeling result. Table 2 shows the comparison of the training and testing time between baseline and proposed methods. We can see that iVoxelDCLa and iVoxelDCLc take more time to train than VoxelDCLa and VoxelDCLc in that they take original input when generating each intermediate feature map. In VoxelDCL, the use of concatenation slightly increases the training and testing time. All the proposed methods take more time to train and test than the baseline model, but the increase is not dramatic. Overall, we do not expect this to be a major bottleneck of the proposed methods."}, {"section_title": "Timing Comparison", "text": ""}, {"section_title": "CONCLUSION AND DISCUSSION", "text": "In this work, we propose the VoxelDCL to address the checkerboard artifact problem of 3D deconvolutional layers. VoxelDCL generates the intermediate feature maps of 3D deconvolutional layers sequentially, thereby building relationships among the adjacent voxels on the output feature maps. We then build four variations of the voxel deconvolutional networks (VoxelDCN) and apply them to the ADNI and LONI PBA40 datasets for volumetric brain image labeling tasks. Experimental results demonstrate the effectiveness of our methods. All of the proposed methods outperform U-Net with regular 3D deconvolutional layers. This indicates that developing dependencies among the intermediate feature maps in deconvolutional layers indeed alleviates the checkerboard artifact issue, thereby improving the prediction results. In out current study, we apply the VoxelDCL to U-Net for voxel-wise prediction tasks. Generally, this layer can be applied to various 3D deep network architectures with up-sampling operations. We plan to apply the proposed methods to models like 3D generative adversarial networks for image generation task in the future."}, {"section_title": "ACKNOWLEDGMENTS", "text": "This work was supported in part by National Science Foundation grants DBI-1641223, DBI-1661289, IIS-1615035, and National Institutes of Health grants EB008374 and AG041721.\nResearch Track Paper KDD 2018, August 19-23, 2018 , London, United Kingdom "}]