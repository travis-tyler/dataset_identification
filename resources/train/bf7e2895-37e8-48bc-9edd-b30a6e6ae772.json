[{"section_title": "Abstract", "text": "Metric plays a key role in the description of similarity between samples. An appropriate metric for data can well represent their distribution and further promote the performance of learning tasks. In this paper, to better describe the heterogeneous distributions of data, we propose a semi-supervised local-toglobal metric learning framework from the geometric insight. Our contributions can be summarized as: Firstly, to enlarge the application scope of local metric learning, we introduce the unsupervised information as the regularization term into our smoothly glued nonlinear metric model. Secondly, we propose two different nonlinear semi-supervised metric learning models with two different loss terms, and find that the smooth loss performs better than the hinge loss by comparison results. Thirdly, we have established not only two metric learning models, but also a nonlinear metric learning framework based on local metrics, which includes supervised and semi-supervised as well as linear and nonlinear metric learning. Moreover, we present an intrinsic steepest descent algorithm on the positive definite manifold for implementation of our semi-supervised nonlinear metric learning models with smooth triplet constrain loss. Finally, we compare our approaches with several state-of-the-art methods on a variety of datasets. The results validate that the robustness and accuracy of classification are both improved under our metrics.\nINDEX TERMS Local metric learning, semi-supervised method, partition of unity, intrinsic steep descent method."}, {"section_title": "I. INTRODUCTION", "text": "In artificial intelligence tasks, it is often required to judge whether a sample is similar or dissimilar to others. Thus, we need a measurement to evaluate the similarity of samples. Metric is often used as a tool for this purpose. Therefore, learning an appropriate distance metric to measure the distance or similarity between samples, i.e., metric learning, becomes one of the key topics in machine learning [1] - [4] . The applications of metric learning include re-identification, medical image analysis and place recognition [5] - [10] .\nFrom the geometric viewpoint, metric learning can be categorized as linear and nonlinear metric learnings [11] , [12] . For example, the linear metric learning can be formulated by a globally linear mapping from the original domain to the new data space.\nThe associate editor coordinating the review of this manuscript and approving it for publication was Wei Liu.\nTo improve the separability in classification and retrieval tasks, metric learning often aims to find an appropriate distance metric which keeps similar samples closer while dissimilar ones farther. A variety of linear metric learning methods are developed, such as Distance Metric Learning (DML) [13] , Neighborhood Component Analysis (NCA) [14] , Large Margin Nearest Neighbors (LMNN) [15] , and Mirror Descent Metric Learning (MDML) [16] . Among them, LMNN is the most representative method which separates samples from different classes with a large margin while keeping k-nearest neighbors similar and tight [15] . Both empirically and theoretically, these metric learning methods can significantly improve the performance in a variety of machine learning problems via a linear global metric. In many real world applications, however, such methods cannot fit the complicated data distribution well and lead to unsatisfactory performance.\nTherefore, many methods on nonlinear metric learning, including kernel and multi-metric methods, have been VOLUME 8, 2020 This work is licensed under a Creative Commons Attribution 4.0 License. For more information, see http://creativecommons.org/licenses/by/4.0/ proposed and performed well on many real datasets. In particular, kernel-basic metric learning is to map the original low-dimensional data into a high-dimensional feature space for a better separation. Davis et al. [17] kernelize the model by a low-rank kernel learning method in Information-Theoretic Metric Learning (ITML). Jain et al. [18] propose a general kernel-based framework for learning metrics via linear transformations, which bridges the metric learning and kernel learning. Later, Li et al. [19] develop a multiple kernel metric learning method to choose an appropriate kernel for classification. However, the computational burden limits their application to large scale datasets. Meanwhile, multi-metric learning is to learn multiple local metrics on local regions [20] , [21] . A usual kind of local metric learning method constructs either instance-specific metrics [22] or cluster-specific metrics based on prior knowledge such as label information [23] . For instance, Zhan et al. propose an Instance Specific Distances learning by metric propagation under a convex optimization framework, which propagates and adapts metrics of individual labeled instances to individual unlabeled ones. Wang et al. [24] propose Parametric Local Metric Learning (PLML) based on LMNN, which defines several anchor points with different basic Mahalanobis metrics. Later, Peng et al. [25] develop Global Nonlinear Smooth Metric Learning (GNSML) by gluing the local linear metrics, which constructs a smooth nonlinear metric for every sample. Then, Nguyen et al. [26] propose the Clustered Multi-Metric Learning (CMML) by learning multiple distance metrics jointly with triplet constraints constructed in clusters.\nNevertheless, these methods are supervised and do not sufficiently consider those unlabeled data. Thus, making good use of those large amounts of unlabeled data is a challenging problem. Semi-supervised methods can exploit the information of labeled and unlabeled data to learn an appropriate metric, which combines the advantages of supervised and unsupervised metric learning methods. With semi-supervised clustering, Bilenko et al. [27] conduct distance metric learning by using the pairwise constraints to learn an appropriate metric. Later, on the basis of such model, Hoi et al. [28] propose a semi-supervised metric learning method, which encodes the similarity between point pairs with a weight matrix and a graph Laplacian regularity. Moreover, Li and Fu [29] introduce the low-rank constraint into the semi-supervised metric learning. Liu et al. [30] construct the weight matrix in a refined way. Baghshah and Shouraki [31] , Zhong et al. [32] and Wang et al. [33] use different manifold regularizers respectively, in which Wang et al. define three semi-supervised assumptions, i.e., smoothness, manifold and cluster, via density and similarity [33] .\nHowever, most of these semi-supervised metric learning methods simply learn a global linear metric, which may fail to deal with heterogeneously distributed data. Furthermore, we need a smooth metric defined on every point in the entire space, not only on the training set. In this paper, we propose a semi-supervised local-to-global metric learning framework with multi-local metrics for heterogeneously distributed data, which introduces the manifold regularization to preserve the data structure. In particular, we conduct metric learning by smoothly gluing locally linear metrics, whose basic framework is illustrated in Fig. 1 . It is worth to mention that, as illustrated in Fig. 2 , our framework can handle the heterogeneously distributed data well, while the global metric learning method LMNN fails.\nThe remainder of this paper is organized as follows. In Section II, we introduce a local-to-global metric construction theory and strategy with the partition of unity. Under this metric construction, in Section III we propose a semi-supervised multi-metric learning framework, and then discuss two models for the semi-supervised local metric learning problem with different triplet constraint losses and the associated optimization algorithms. In Section IV, we conduct extensive experiments to validate the effectiveness of the proposed methods. Section V concludes the paper."}, {"section_title": "II. THE PROPOSED METHODOLOGY", "text": "The goal of metric learning is to learn an appropriate metric for describing data. Since the data are often nonlinear and heterogeneously distributed and can be viewed lying on a latent manifold, a global linear metric is no longer proper. As we know, manifold can be viewed as Euclidean locally. Intuitively, to fit the data manifold locally, we consider learning multiple local linear metrics since similar samples share the similar distribution within a local area. Then we glue these local metrics smoothly to have a smooth nonlinear metric for every point in the entire data space."}, {"section_title": "A. THE LOCAL-TO-GLOBAL METRIC CONSTRUCTION", "text": "Therefore, a smooth way to glue the locally linear metric on the data manifold is needed. Fortunately, the theorem of Partition of Unity [34] , an important theorem in differentiable manifold, establishes a bridge from local to global. Intuitively, we can use the theorem of Partition of Unity for gluing the local structures to obtain a global smooth metric and to fit the data manifold. Here we state one version of the theorem. \nA collection that satisfies 1) to 3) is called a C \u221e partition of unity for A. Moreover, if also satisfies 4), it is said to be subordinate to the cover O. We introduce the strategy to construct a novel local-to-global distance metric via the Partition of Unity in the following.\nGiven a dataset D = {x 1 , \u00b7 \u00b7 \u00b7 , x n }, where x i \u2208 R d , without loss of generality, we assume that the first l samples in D are the labeled data L = {x 1 , \u00b7 \u00b7 \u00b7 , x l } with the label Y = {y 1 , \u00b7 \u00b7 \u00b7 , y l }.\nDefinition 1 (Smoothly Glued Metric): Suppose we construct a partition of unity {\u03c6 c \u2208 C \u221e (M) | 1 \u2264 c \u2264 N } on the data manifold M (samples are finite so the manifold is compact) such that the global metric M at any point x could be defined as: These local regions could 1) be clusters acquired via some structure unsupervised methods, such as k-means; and 2) depend on the label information of classes. For simplicity, we allow different classes be viewed as different regions in our experiments. So, N could be the number of different classes. Then the squared distance between two samples x i and x j can be defined as:\nObviously, the symmetry D 2 ij = D 2 ji cannot be satisfied when the metrics defined on M (x i ) and M (x j ) are different. We then introduce a symmetric metric as\nTherefore, the distance between x i and x j can be rewritten with the symmetrical metric\nThe key of this work is the construction of truncated functions {\u03c6 c } N c=1 . Unlike most existing metrics defined only on the training data, we try to define a metric on every point in the entire data space by establishing the truncated function with the heatdiffusion:\n, where x c is the center point of the c-th class, and \u03c3 0 is a hyperparameter to describe the covering of samples. By definition, the value of f c (x) is inversely proportional to the distance between sample x and x c , which means that the basic metric M c would have less effect on the samples farther away from the class center. As long as the basic metrics are given, the global metric value at any sample x is determined. Thus, we obtain the smooth metric function defined on every point in the entire manifold."}, {"section_title": "B. THE PROPOSED SEMI-SUPERVISED METRIC LEARNING FRAMEWORK", "text": "In this section, we firstly propose a semi-supervised metric learning framework by defining an objective function as\nwhere L is the loss of data fitting term, and Reg is the regularization term. Here 0 \u2264 \u03bb \u2264 1 is a trade-off parameter. Usually, the loss term keeps the inner-and inter-class data balanced, and the regularization term controls the smoothness and structure."}, {"section_title": "C. THE TRIPLET CONSTRAINT LOSS", "text": "For well fitting the data and quantifying the similarity of the samples, we introduce a triplet constraint in an intuitive way, i.e.,\nwhere x i is similar to x j , and dissimilar to x k . It means that the distance of samples in different classes should be as large as possible, while as small as possible in the same class. Hinge loss function [25] [15] is often used for the triplet constraint\nwhere [m] + = m if m \u2265 0, and 0 otherwise. It is clear that the hinge loss function is non-smooth and time-consuming for computation. Furthermore, to balance the scale between the similar and dissimilar data, we rewrite the triplet constraint in a smooth version as\nby introducing an adaptive parameter \u03b3 = 1/(1 +D \u22121 ) \u2208 (0, 1], whereD is the mean distance between samples. The parameter \u03b3 fully depends on the distribution of dataset, and can well balance the difference of inner-and inter-class. Then, we obtain the corresponding smooth loss function for this smooth triplet constraint as\nWith this loss function, we can well describe the dataset structure and reduce the computation complexity. Nevertheless, the corresponding loss term is supervised and prone to over-fitting due to the absence of regularization, especially in high dimensions."}, {"section_title": "D. REGULARIZATION TERM", "text": "Inspired by the regularization method in [33] , with the help of some unlabeled data, we introduce a regularizer\nto better describe the sample structure and distribution.\nHere \u03b2 i \u2208 R + is a parameter related to density for the sample x i , N (i) is the set of the neighbor samples of x i , and S ij is the similarity between x i and x j . This term can better preserve the topology structure by penalizing large distance between inputs and their neighbors. Moreover, an adaptive weight depending on density is used to penalize the cluster information. The regularization term is unsupervised since the label information are unknown."}, {"section_title": "E. SEMI-SUPERVISED METRIC LEARNING MODELS", "text": "Based on the analysis of the triplet constraint loss (2) (3) and regularizer (4), the optimization problem for semi-supervised metric learning framework can be established.\nWe consider two semi-supervised metric learning models based on different triplet constraints respectively, namely Partition of Unity based Local Learning Metric with Hinge loss (PULLMH) and Partition of Unity based Local Learning Metric with Smooth constraint (PULLMS). The two models can be presented as\nand\nrespectively. E H is the objective function of PULLMH, while E S is that of PULLMS. In fact, the previous work [35] [25] can be viewed as two special cases of our metric learning framework when the local metrics M 1 , \u00b7 \u00b7 \u00b7 , M N are the same or the trade-off parameter \u03bb = 0 respectively."}, {"section_title": "III. OPTIMIZATION", "text": "We will optimize these two models with different optimization methods in this section."}, {"section_title": "A. OPTIMIZATION MODEL WITH HINGE LOSS -PULLMH", "text": "The optimization problem for PULLMH can be rewritten as:\nand h ij = 1 x i and x j are neighbors in the same class; 0 otherwise y ik = 1 x i and x k are in the same class; 0 x i and x k are in different classes are indicator functions respectively. The second term in (7) is the loss, penalizing small distances between samples with different labels. We hope that there exists a finite margin (default 1) between samples with different labels. Like [23] , we implement an iterative sub-gradient projection method to optimize the model (7) in terms of the positive semi-definite metrics M 1 , \u00b7 \u00b7 \u00b7 , M N .\nSpecifically, to simplify the notation, let\n. Then at the t-th iteration, the squared distance between x i and x j is D 2\nConsequently, (7) can be rewritten as:\nNote that (8) is piecewise linear with respect to the basic metrics M 1 , \u00b7 \u00b7 \u00b7 , M N . Without the loss of generality, we define a set of triplets N t , such that (i, j, k) \u2208 N t if and only if the indices (i, j, k) trigger the hinge loss in (8) . Then we can get the gradient G c (t) of E(M c ) as:\nThus, at the next (t + 1)-th iteration,\nwhere \u03b1(t) is the optimal step-size at t-th iteration. Since (8) requires the positive semi-definiteness of the basic metric M c , we projectM c (t + 1) onto the positive semi-definite cone:\nwhere V and are the matrices of eigenvectors and eigenvalues ofM c (t + 1). Therefore, we have the iterative formula of metrics.\nHowever, the sub-gradient projection method can only find a semi-definite positive matrix, which in fact is a pseudometric since it cannot satisfy the distinguishability. Therefore, we use the intrinsic steepest descent (ISD) algorithm to solve the optimization problem (6) on positive definite matrix group."}, {"section_title": "B. OPTIMIZATION MODEL WITH SMOOTH LOSS -PULLMS", "text": "The optimization problem for PULLMS can be rewritten as:\nIt is remarkable that the basic metrics M 1 , \u00b7 \u00b7 \u00b7 , M N in (10) are positive definite and can be solved in the positive definite matrix group with intrinsic matrix iteration. To achieve that, we rewrite the model as a minimization problem with the variable of matrix.\nFirst, we translate the loss term in (10) as\nwhere Y = (y ij ) l\u00d7l and H = (h ij ) l\u00d7l are indicator matrices, 1 is a column vector with all elements 1, and e i is a column vector with all elements 0 but the ith element 1. If let\nBecause\nEq. (11) can be rewritten by\nwhere X L = [x 1 , \u00b7 \u00b7 \u00b7 , x l ] is the labeled data matrix, D c P = diag(diag(P( c ) T + P T c )), Q c = P c , and is the multiplication between corresponding elements in two matrices.\nSimilarly, we can calculate the regularization term:\nwhere\nand W ij = \u03b2 i N ij S ij . VOLUME 8, 2020 Clearly, similar to the loss term, the regularization term of (10) can be rewritten by (10) is rewritten in the matrix form:\nwhere\nIn order to avoid solving (14) on a positive definite matrix group and projecting onto the PSD cone, we use the ISD algorithm [36] [35]."}, {"section_title": "1) GEODESIC STRUCTURE ON SYMMETRIC POSITIVE DEFINITE GROUP", "text": "Let P(n) be the set of all n-th order symmetric positive definite matrices. That is, P(n) := {P \u2208 R n\u00d7n |P = P T , P 0}.\nNote that P(n) is a smooth Riemannian manifold with dimension n(n + 1)/2. Its tangent space T P P(n) at the point P \u2208 P(n) represents the set of all tangent vectors at point P, which is a local linearization of P(n) at the point P. Then, from the Riemannian manifold structure, a geodesic starting from the identity I along the direction of S \u2208 T I P(n) is given explicitly by the exponential map exp(tS) in the neighborhood of I .\nAs shown in Fig. 3 , using the invariance under congruent transformations, the blue geodesic P(t) with P(0) = P \u2208 P(n) and\u1e56(0) = S \u2208 T P P(n) is therefore given by"}, {"section_title": "2) INTRINSIC ITERATIVE ALGORITHM FOR PULLMS MODEL", "text": "Inspired by the geodesic structure on symmetric positive definite group, on the positive definite matrix group, the iterative formula from the current step M c (t) to the next step M c (t + 1) turns to be\nwhere M c (t) \u2212 1 2 S(t)M c (t) \u2212 1 2 is a descent direction, and \u03b1(t) is the optimal step-size at time t. The minor gradient, i.e., the steepest descent direction, is always selected as the descent direction. Then, the iterative formula is rewritten by According to the objective function E S (M 1 , \u00b7 \u00b7 \u00b7 , M N ) of (14), we gain a steepest descent flow (16) on the positive definite matrix group. Generally, the gradient of the objective function should be symmetrized with a symmetric operator\nbefore it is selected as the gradient direction. It is remarkable that, in the geometric viewpoint, the symmetrization of the gradient is a projection of the gradient vector to the Lie algebra of the positive definite matrix group.\nThe symmetrization step is omitted here, since the gradient of the objective function E S in our model (10) is symmetric. That is, we have the descent direction as:\nThe rest is calculating the gradient of the objective function by\nAfter obtaining the partition of unity \u03c6 c (x) and the metric M c , we input the labeled samples and use the learned squared distance D 2 ij for classification via the kNN method."}, {"section_title": "3) THE COMPUTATIONAL COMPLEXITY OF THE PROPOSED OPTIMIZATION METHOD", "text": "Note that the ISD algorithm on matrix manifolds is at least linear convergence. Denoting the precision of the objective function by > 0, the iteration will be terminated at O(log 1 ). In each iteration, the distance with the k-nearest samples should be calculated for n samples, and hence the complexity is O(n 2 ). Therefore, the total complexity is O(n 2 log 1 ). For the local metrics version, in each iteration, n samples should calculate the distance with the k-nearest samples under N basic metrics, and hence the complexity is O(n 2 N ). Therefore, the total complexity is O(n 2 N log 1 )."}, {"section_title": "IV. EXPERIMENTS", "text": "To demonstrate the effectiveness of the proposed metric learning methods, we implement experiments on five datasets, i.e., UCI dataset 1 , ORL face dataset 2 , USPS digit image dataset 3 , COIL-20 object dataset 4 , and Alzheimer's Disease Neuroimaging Initiative (ADNI) dataset 5 . Table 1 provides the details of these datasets, where |L|, |U|, |D| are the sizes of the labeled data, unlabeled data and the whole dataset, respectively, and |L|/|D| is the labeled sample ratio.\nWe evaluate the 1NN classification performance after PULLMH and PULLMS, respectively. Then, we compare them with 1) supervised single metric learning method: LMNN [23] ; 2) semi-supervised single metric learning method: ISSML [35] ;\n3) supervised multiple metric learning methods: multiple metrics LMNN (mmLMNN) [23] , PLML [24] , GNSML [25] and CMML [26] ; 4) a baseline experiment, i.e., the Euclidean method, is conducted by using kNN classifier with the Euclidean distance. The metric matrix M is initialized by the identity matrix I ."}, {"section_title": "A. CLASSIFICATION ON UCI DATASETS", "text": "For UCI, the experiments of classification are conducted on six datasets, i.e., wine, iris, balance, heart, dermatology and ionosphere. We randomly separate all datasets into two subsets: the labeled dataset L, and the unlabeled dataset U. Specifically, we select the same number of samples from each class as the labeled dataset, then the rest samples as the unlabeled dataset. The unlabeled dataset also acts as the testing dataset due to data inadequacy. Training samples are randomly chosen in every experiment. The average results of 30 times are presented."}, {"section_title": "1) EXPERIMENTAL SETTING", "text": "We set different values of the trade-off parameter \u03bb for different datasets, by tuning on the training data. In order to calculate \u03b2 i = f [p(x i )], a simple linear mapping f [p(x i )] = p(x i ) is adopted. We use the Parzen window to estimate the density where N (i) is the neighbor list of x i , its size |N (i)| is set to 10, d is the dimension of the sample x i , h is the bandwidth, and K h : R d \u2192 R is a Gaussian-kernel. Then we normalize the estimated density by p(x i ) := p(x i )/max{p(x)}.\nSimilarity can be calculated as S ij = exp(\u2212d 2 ij /2\u03c3 2 ), where d ij is the Euclidean distance between samples x i and x j , and\nwhere max D and min D are the maximum and minimum Euclidean distances between samples in the dataset, respectively. In our models, the value of v depends on the dataset, varying from 1 to 15."}, {"section_title": "2) EXPERIMENTAL RESULTS", "text": "By using the 1 nearest neighborhood (1NN) classification, the results under the learned metrics via LMNN, ISSML, mmLMNN, PLML, GNSML, CMML and our methods PULLMH, PULLMS are shown in Fig. 4 . Table 2 and Fig. 4 provide the classification results (average error rate) based on a 1NN classifier using different distance metrics. For each dataset, we assign rank 1 to the method with the lowest error, rank 2 to the one with the second-lowest error, and so on. The average rank for each method over all datasets is reported in the last row of Table 2 . We have four observations from Table 2 and Fig. 4 . First, almost all metric learning methods improve the recognition results of the Euclidean distance (without metric learning) on all datasets.\nSecond, according to the average rank, PULLMS performs the best among all methods, followed by PULLMH. It is interesting that CMML performs even worse than some single metric learning methods. This is mainly due to the lack of labeled data in the training process, since CMML needs to use sufficient labeled data to implement the clustered multimetric learning. ISSML works well overall with unlabeled data information.\nThird, methods using the regularizer, i.e., ISSML, PULLMH and PULLMS, are better than LMNN which lacks the regularizer.\nFourth, multiple-metric learning methods are more suitable for nonlinear datasets, while ISSML achieves satisfactory performance on the highly linear dataset iris.\nTo better illustrate the classification effect of PULLMH and PULLMS, we use tSNE [37] to visualize the results on wine and ionosphere, as plotted in Fig. 5 . The local multiple metrics provided by PULLMH and PULLMS with regularization show high discriminative capability, compared with those learned by other methods. Fig. 6 shows the box plot of recognition error rate along with the iteration with 30 tests. Fig. 7 presents the variation of objective function along with the iteration. The recognition error rate and the value of objective function decrease along with the iterations in the statistical sense, and they also converge finally. On the other hand, PULLMS with ISD decreases faster and converges earlier than PULLMH with PSD."}, {"section_title": "3) PARAMETER ANALYSIS", "text": "Moreover, we test the sensitivity of the parameter \u03bb in (10) and v in (17) to compute \u03c3 in Gaussian kernel by fixing other settings. Fig. 8(a) and Fig. 8(c) show the recognition error rate against the parameter \u03bb from 0.1 to 0.9 on UCI. The recognition rates on most datasets are stable when the parameter \u03bb changes. The ionosphere dataset is relatively sensitive to \u03bb in PULLMS. In general, our proposed methods are not very sensitive to the parameter \u03bb.\nWith regard to the parameter v used to calculate \u03c3 in similarity S ij = exp(\u2212d 2 ij /2\u03c3 2 ), where \u03c3 = min D + (1/v)(max D \u2212 min D), we set different values of v for different datasets. When other parameters are fixed, the effect of v to the recognition error rate is presented in Fig. 8(b) and Fig. 8(d) . Clearly, the recognitions in PULLMH are stable to v, while those in PULLMS are a little sensitive.\nTo further test the performance of all algorithms with different magnitudes of labeled data, we select different ratios of labeled data. Fig. 9 shows the changes of the mean recognition error rates with respect to the ratio |L|/|D|. The curves of all methods tend to decrease when the ratio |L|/|D| increases, and our proposed methods have the lowest mean recognition error rates.\nIn general, our proposed methods are more accurate for classification than several conventional methods without losing computational efficiency. At the same time, they are stable to the parameters. For further testing our proposed methods, we apply them to four real datasets for classification and image retrieval below. "}, {"section_title": "B. CLASSIFICATION ON ORL DATASET", "text": "The ORL facial dataset contains 400 images with 40 classes, where the variability between images of the same person is mainly due to different lighting conditions. The images are automatically centered and then converted to vectors. All images are cropped and resized to the size of 32\u00d732. Examples of images from ORL are shown in Fig. 10 .\nWe randomly select 30% of the data as the labeled samples L, 50% as the unlabeled samples U and the rest 20% as the testing samples. Same as the UCI dataset, we compare our performance with the Euclidean, LMNN, ISSML, mmLMNN, PLML, GNSML and CMML. All the algorithm parameters are tuned for the best performance. The test process is repeated 20 times, and the average error rate is used for comparison. The results are shown in Table 3 . Similar experimental setting and result illustration are also implemented on USPS and COIL-20 datasets in the following. Table 3 verifies the efficiency of PULLMS from a numerical point of view, and also in USPS and COIL-20. PULLMH performs unsatisfactory, which may due to the heavy overfitting for large-scale problems. Meanwhile, this demonstrates that the hinge loss function is not suitable for smooth gluing metrics. We can find that LMNN is effective and stable for this kind of problems. "}, {"section_title": "C. RETRIEVAL ON USPS DATASET", "text": "USPS is a handwritten digits dataset with grayscale images of '0' through '9'. The digits have been normalized to size 16\u00d716 gray-level images. Thus the dimension of input space is 256. It is used to validate algorithms for image retrieval in [38] . The results are shown in Table 3 and Fig. 11 . Fig. 11 shows the nearest sample to the query image under the metrics of Euclid, LMNN, ISSML, mmLMNN, PLML, GNSML, CMML and our proposed methods PULLMH and PULLMS, respectively. The first row shows the queries. The rest rows correspond to the nearest neighbors of the queries obtained under metric learning methods. It indicates that PULLMS finds much better results than the methods using other learned metrics."}, {"section_title": "D. RETRIEVAL ON COIL-20 DATASET", "text": "COIL-20 is a 3D object dataset containing 1440 images with 20 different objects. Each object contains 72 images with size 128\u00d7128, where each image corresponds to a projection angle ranging from 0 \u2022 to 355 \u2022 with an interval of 5 degrees. Before training, we conduct principal component analysis (PCA) on the whole COIL-20 to reduce the dimension and relieve the computation burden, and it only contains 1439 principal components. Thus we reduce all samples to 1439 dimension with PCA and then train the metric learning model. The experiment results are shown in Table 3 and Fig. 12 . Fig. 12 shows some results about retrieved samples. The first row is the retrieval samples, and the rest are the retrieved images obtained with the Euclidean distance and other metrics. It can be seen that PULLMS improves the retrieval performance effectively."}, {"section_title": "E. ANALYSIS ON ADNI DATASET", "text": "ADNI is a medical dataset consisting of 51 Alzheimer's Disease (AD) patients and 52 normal controls (NC) with 93 features, extracting from MRI images. We select 10 AD patients and 10 NC as the labeled dataset L randomly and the rest as the unlabeled dataset U, which also as the test set due to the lack of samples. Every experiment selects the training samples randomly and the average results of repeated 30 times are presented in Table 4 .\nTo evaluate the performance of those metric learning methods, in ADNI dataset, besides the average recognition error rate, we adopt the area under ROC curve (AUC) and F1-score. We can find that PULLMS outperforms other state-of-the-art methods under different evaluation indexes."}, {"section_title": "V. CONCLUSION", "text": "In this paper, we have extended the smoothly glued local metric learning method to a nonlinear semi-supervised metric learning framework via introducing a manifold regularization to preserve the data structure. We have proposed two different nonlinear semi-supervised metric learning models with two different loss terms, showing that the smooth loss performs better than the hinge loss. Comparison with several state-of-the-art methods on standard datasets shows that our proposed method improves the accuracy of classification and the robustness. "}]