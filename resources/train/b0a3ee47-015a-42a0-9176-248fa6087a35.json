[{"section_title": "Abstract", "text": "High-dimensional regression/classification continues to be an important and challenging problem, especially when features are highly correlated. Feature selection, combined with additional structure information on the features has been considered to be promising in promoting regression/classification performance. Graph-guided fused lasso (GFlasso) has recently been proposed to facilitate feature selection and graph structure exploitation, when features exhibit certain graph structures. However, the formulation in GFlasso relies on pairwise sample correlations to perform feature grouping, which could introduce additional estimation bias. In this paper, we propose three new feature grouping and selection methods to resolve this issue. The first method employs a convex function to penalize the pairwise l \u221e norm of connected regression/classification coefficients, achieving simultaneous feature grouping and selection. The second method improves the first one by utilizing a non-convex function to reduce the estimation bias. The third one is the extension of the second method using a truncated l 1 regularization to further reduce the estimation bias. The proposed methods combine feature grouping and feature selection to enhance estimation accuracy. We employ the alternating direction method of multipliers (ADMM) and difference of convex functions (DC) programming to solve the proposed formulations. Our experimental results on synthetic data and two real datasets demonstrate the effectiveness of the proposed methods."}, {"section_title": "INTRODUCTION", "text": "High-dimensional regression/classification is challenging due to the curse of dimensionality. Lasso [18] and its various extensions, which can simultaneously perform feature selection and regression/classification, have received increasing attention in this situation. However, in the presence of highly correlated features lasso tends to only select one of those features resulting in suboptimal performance [27] . Several methods have been proposed to address this issue in the literature. Shen and Ye [15] introduce an adaptive model selection procedure that corrects the estimation bias through a data-driven penalty based on generalized degrees of freedom. The Elastic Net [27] uses an additional l 2 regularizer to encourage highly correlated features to stay together. However, these methods do not incorporate prior knowledge into the regression/classification process, which is critical in many applications. As an example, many biological studies have suggested that genes tend to work in groups according to their biological functions, and there are some regulatory relationships between genes [10] . This biological knowledge can be represented as a graph, where the nodes represent the genes, and the edges imply the regulatory relationships between genes. Therefore, we want to study how estimation accuracy can be improved using dependency information encoded as a graph.\nGiven feature grouping information, the group lasso [1, 7, 22, 11] yields a solution with grouped sparsity using l 1/l2 penalty. The orignal group lasso does not consider the overlaps between groups. Zhao et al. [24] extend the group lasso to the case of overlapping groups. Jacob et al. [7] introduce a new penalty function leading to a grouped sparse solution with overlapping groups. Yuan et al. [21] propose an efficient method to solve the overlapping group lasso. Other extensions of group lasso with tree structured regularization include [11, 8] . Prior works have demonstrated the benefit of using feature grouping information for highdimensional regression/classification. However, these methods need the feature groups to be pre-specified. In other words, they only utilize the grouping information to obtain solutions with grouped sparsity, but lack the capability of identifying groups.\nThere are also a number of existing methods for feature grouping. Fused lasso [19] introduces an l 1 regularization method for estimating subgroups in a certain serial order, but pre-ordering features is required before using fused lasso. A study about parameter estimation of the fused lasso can be found in [12] ; Shen et al. [13] propose a non-convex method to select all possible homogenous subgroups, but it fails to obtain sparse solutions. OSCAR [2] employs an l 1 regularizer and a pairwise l \u221e regularizer to perform feature selection and automatic feature grouping. Li and Li [10] suggest a grouping penalty using a Laplacian matrix to force the coefficients to be similar, which can be considered as a graph version of the Elastic Net. When the Laplacian matrix is an identity matrix, Laplacian lasso [10, 5] is identical to the Elastic Net. GFlasso employs an l 1 regularization over a graph, which penalizes the difference |\u03b2 i \u2212 sign(rij)\u03b2j|, to encourage the coefficients \u03b2 i, \u03b2j for features i, j connected by an edge in the graph to be similar when r ij > 0, but dissimilar when r ij < 0, where rij is the sample correlation between two features [9] . Although these grouping penalties can improve the performance, they would introduce additional estimation bias due to strict convexity of the penalties or due to possible graph misspecification. For example, additional bias may occur when the signs of coefficients for two features connected by an edge in the graph are different in Laplacian lasso [10, 5] , or when the sign of r ij is inaccurate in GFlasso [9] .\nIn this paper, we focus on simultaneous estimation of grouping and sparseness structures over a given undirected graph. Features tend to be grouped when they are connected by an edge in a graph. When features are connected by an edge in a graph, the absolute values of the model coefficients for these two features should be similar or identical. We propose one convex and two non-convex penalties to encourage both sparsity and equality of absolute values of coefficients for connected features. The convex penalty includes a pairwise l \u221e regularizer over a graph. The first non-convex penalty improves the convex penalty by penalizing the difference of absolute values of coefficients for connected features. The other one is the extension of the first non-convex penalty using a truncated l 1 regularization to further reduce the estimation bias. These penalties are designed to resolve the aforementioned issues of Laplacian lasso and GFlasso. The non-convex penalties shrink only small differences in absolute values so that estimation bias can be reduced; several recent works analyze their theoretical properties [26, 14] . Through ADMM and DC programming, we develop computational methods to solve the proposed formulations. The proposed methods can combine the benefit of feature selection and that of feature grouping to improve regression/classification performance. Due to the equality of absolute values of coefficients, the model complexity of the learned model can be reduced. We have performed experiments on synthetic data and two real datasets. The results demonstrate the effectiveness of the proposed methods.\nThe rest of the paper is organized as follows. We introduce the proposed convex method in Section 2, and the two proposed non-convex methods in Section 3. Experimental results are given in Section 4. We conclude the paper in Section 5."}, {"section_title": "A CONVEX FORMULATION", "text": "Consider a linear model in which response yi depends on a vector of p features:\nwhere \u03b2 \u2208 R p is a vector of coefficients, X \u2208 R n\u00d7p is the data matrix, and \u03b5 is random noise. Given an undirected graph, we try to build a prediction model (regression or classification) incorporating the graph structure information to estimate the nonzero coefficients of \u03b2 and to identify the feature groups when the number of features p is larger than the sample size n. Let (N, E) be the given undirected graph, where N = {1, 2, . . . , p} is a set of nodes, and E is the set of edges. Node i corresponds to feature x i. If nodes i and j are connected by an edge in E, then features x i and xj tend to be grouped. The formulation of graph OSCAR (GOSCAR) is given by\nwhere \u03bb1, \u03bb2 are regularization parameters. We use a pairwise l \u221e regularizer to encourage the coefficients to be equal [2] , but we only put grouping constraints over the nodes connected over the given graph. The l 1 regularizer encourages sparseness. The pairwise l \u221e regularizer puts more penalty on the larger coefficients. Note that max{|\u03b2 i|, |\u03b2j|} can be decomposed as\nwhere u, v are sparse vectors, each with only two non-zero entries\n. Thus Eq. (2) can be rewritten in a matrix form as\nwhere T is a sparse matrix constructed from the edge set E. The proposed formulation is closely related to OSCAR [2] . The penalty of OSCAR is \u03bb 1 \u03b2 1 + \u03bb2 i<j max{|\u03b2i|, |\u03b2j|}. The l 1 regularizer leads to a sparse solution, and the l\u221e regularizer encourages the coefficients to be equal. OSCAR can be efficiently solved by accelerated gradient methods, whose key projection can be solved by a simple iterative group merging algorithm [25] . However, OSCAR assumes each node is connected to all the other nodes, which is not sufficient for many applications. Note that OSCAR is a special case of GOSCAR when the graph is complete. GOSCAR, incorporating an arbitrary undirected graph, is much more challenging to solve."}, {"section_title": "Algorithm", "text": "We propose to solve GOSCAR using the alternating direction method of multipliers (ADMM) [3] . ADMM decomposes a large global problem into a series of smaller local subproblems and coordinates the local solutions to identify the globally optimal solution. ADMM attempts to combine the benefits of dual decomposition and augmented Lagrangian methods for constrained optimization [3] . The problem solved by ADMM takes the form of\nADMM uses a variant of the augmented Lagrangian method and reformulates the problem as follows:\nwith \u03bc being the augmented Lagrangian multiplier, and \u03c1 being the non-negative dual update step length. ADMM solves this problem by iteratively minimizing L \u03c1(x, z, \u03bc) over x, z, and \u03bc. The update rule for ADMM is given by\nConsider the unconstrained optimization problem in Eq. (3), which is equivalent to the following constrained optimization problem:\nwhere q, p are slack variables. Eq. (4) can then be solved by ADMM. The augmented Lagrangian is\nwhere \u03bc, \u03c5 are augmented Lagrangian multipliers. Update \u03b2: In the (k + 1)-th iteration, \u03b2 k+1 can be updated by minimizing L \u03c1 with q, p, \u03bc, \u03c5 fixed:\nThe above optimization problem is quadratic. The optimal solution is given by\nThe computation of \u03b2 k+1 involves solving a linear system, which is the most time-consuming part in the whole algorithm. To compute \u03b2 k+1 efficiently, we compute the Cholesky factorization of F at the beginning of the algorithm:\nNote that F is a constant and positive definite matrix. Using the Cholesky factorization we only need to solve the following two linear systems at each iteration:\nSince R is an upper triangular matrix, solving these two linear systems is very efficient. Update q: q k+1 can be obtained by solving\nwhich is equivalent to the following problem:\nEq. (7) has a closed-form solution, known as soft-thresholding:\nwhere the soft-thresholding operator is defined as:\nUpdate p: Similar to updating q, p k+1 can also be obtained by soft-thresholding:\nUpdate \u03bc, \u03c5:\nA summary of GOSCAR is shown in Algorithm 1."}, {"section_title": "Algorithm 1:", "text": "The GOSCAR algorithm Input: X, y, E, \u03bb1, \u03bb2, \u03c1 Output: In Algorithm 1, the Cholesky factorization only needs to be computed once, and each iteration involves solving one linear system and two soft-thresholding operations. The time complexity of the soft-thresholding operation in Eq. (8) is O(p). The other one in Eq. (9) involves a matrix-vector multiplication. Due to the sparsity of T, its time complexity is O(n e), where ne is the number of edges. Solving the linear system involves computing b k and solving Eq."}, {"section_title": "(6), whose total time complexity is O(p(p + n) + n e). Thus the time complexity of each iteration is O(p(p + n) + n e).", "text": ""}, {"section_title": "TWO NON-CONVEX FORMULATIONS", "text": "The grouping penalty of GOSCAR overcomes the limitation of Laplacian lasso that the different signs of coefficients can introduce additional penalty. However, under the l \u221e regularizer, even if |\u03b2i| and |\u03b2j| are close to each other, the penalty on this pair may still be large due to the property of the max operator, resulting in the coefficient \u03b2 i or \u03b2j being over penalized. The additional penalty would result in biased estimation, especially for large coefficient, as in the lasso case [18] . Another related grouping penalty is GFlasso, |\u03b2 i \u2212 sign(rij)\u03b2j|, where rij is the pairwise sample correlation. GFlasso relies on the pairwise sample correlation to decide whether \u03b2 i and \u03b2j are enforced to be close or not. When the pairwise sample correlation wrongly estimates the sign between \u03b2 i and \u03b2j, an additional penalty on \u03b2i and \u03b2j would occur, introducing estimation bias. This motivates our non-convex grouping penalty, ||\u03b2 i| \u2212 |\u03b2j||, that shrinks only small differences in absolutes values. As a result, estimation bias is reduced as compared to these convex grouping penalties. The proposed non-convex methods perform well even when the graph is wrongly specified, unlike GFlasso. Note that the proposed non-convex grouping penalty does not assume the sign of an edge is given; it only relies on the graph structure."}, {"section_title": "Non-Convex Formulation I: ncFGS", "text": "The proposed non-convex formulation (ncFGS) solves the following optimization problem:\nwhere the grouping penalty (i,j)\u2208E ||\u03b2i| \u2212 |\u03b2j|| controls only magnitudes of differences of coefficients ignoring their signs over the graph. Through the l 1 regularizer and grouping penalty, simultaneous feature grouping and selection are performed, where only large coefficients as well as pairwise differences are shrunk. A computational method for the non-convex optimization in Eq. (11) is through DC programming. We will first give a brief review of DC programming.\nA particular DC program on R p takes the form of\nwith f1(\u03b2) and f2(\u03b2) being convex on R p . Algorithms to solve DC programming based on the duality and local optimality conditions have been introduced in [17] . Due to their local characteristic and the non-convexity of DC programming, these algorithms cannot guarantee the computed solution to be globally optimal. In general, these DC algorithms converge to a local solution, but some researchers observed that they converge quite often to a global one [16] .\nTo apply DC programming to our problem we need to decompose the objective function into the difference of two convex functions. We propose to use:\nThe above DC decomposition is based on the following identity: ||\u03b2 i| \u2212|\u03b2j|| = |\u03b2i + \u03b2j| + |\u03b2i \u2212 \u03b2j| \u2212 (|\u03b2i| + |\u03b2j|). Note that both f 1(\u03b2) and f2(\u03b2) are convex functions.\nDenote f\nas the affine minorization of f 2(\u03b2), where \u00b7, \u00b7 is the inner product. Then DC programming solves Eq. (11) by iteratively solving a sub-problem as follows:\nSince\nLet\nwhere di is the degree of node i, and I(\u00b7) is the indicator function. Hence, the formulation in Eq. (13) is\nwhich is convex. Note that the only differences between the problems in Eq. (2) and Eq. (15) are the linear term (c k ) T \u03b2 and the second regularization parameter. Similar to GOSCAR, we can solve Eq. (15) using ADMM, which is equivalent to the following optimization problem: \nwhere s represents the iteration number in Algorithm 1. The key steps of ncFGS are shown in Algorithm 2."}, {"section_title": "Algorithm 2:", "text": "The ncFGS algorithm Input: X, y, E, \u03bb1, \u03bb2, Output: \u03b2 Initialization:"}, {"section_title": "Non-Convex Formulation II: ncTFGS", "text": "It is known that the bias of lasso is due to the looseness of convex relaxation of l 0 regularization. The truncated l1 regularizer, a non-convex regularizer close to the l0 regularizer, has been proposed to resolve the bias issue [23] . The truncated l 1 regularizer can recover the exact set of nonzero coefficients under a weaker condition, and has a smaller upper error bound than lasso [23] . Therefore, we propose a truncated grouping penalty to further reduce the estimation bias. The proposed formulation based on the truncated grouping penalty is\nwhere\nand J\u03c4 (x) = min(\nis the truncated l1 regularizer, a surrogate of the l 0 function; \u03c4 is a non-negative tuning parameter. Figure 1 shows the difference between l 0 norm, l1 Note that J \u03c4 (||\u03b2i| \u2212 |\u03b2j||) can be decomposed as\nand a DC decomposition of J\u03c4 (|\u03b2i|) is\nHence, the DC decomposition of fT (\u03b2) can be written as\nThen the subproblem of ncTFGS is min \u03b2\nwhich can be solved using Algorithm 1 as in ncFGS.\nThe key steps of ncTFGS are summarized in Algorithm 3."}, {"section_title": "Algorithm 3:", "text": "The ncTFGS algorithm Input: X, y, E, \u03bb1, \u03bb2, \u03c4, Output: \u03b2 Initialization: ncTFGS is an extension of ncFGS. When \u03c4 \u2265 |\u03b2i|, \u2200i, ncT-FGS with regularization parameters \u03c4 \u03bb 1 and \u03c4 \u03bb2 is identical to ncFGS (see Figure 3 ). ncFGS and ncTFGS have the same time complexity. The subproblems of ncFGS and ncTFGS are solved by Algorithm 1. In our experiments, we observed ncFGS and ncTFGS usually converge in less than 10 iterations."}, {"section_title": "NUMERICAL RESULTS", "text": "We examine the performance of the proposed methods and compare them against lasso, GFlasso, and OSCAR on synthetic datasets and two real datasets: FDG-PET images 1 and Breast Cancer 2 . The experiments are performed on a PC with dual-core Intel 3.0GHz CPU and 4GB memory. The code is written in MATLAB. The algorithms and their associated penalties are:\n\u2022 Lasso: \u03bb 1 \u03b2 1;\n\u2022 OSCAR: \u03bb1 \u03b2 1 + \u03bb2 i<j max{|\u03b2i|, |\u03b2j|};\n\u2022 GFlasso: \u03bb 1 \u03b2 1 + \u03bb2 (i,j)\u2208E |\u03b2i \u2212 sign(rij)\u03b2j|;\n\u2022 GOSCAR: \u03bb 1 \u03b2 1 + \u03bb2 (i,j)\u2208E max{|\u03b2i|, |\u03b2j|};\n\u2022 ncFGS: \u03bb 1 \u03b2 1 + \u03bb2 (i,j)\u2208E ||\u03b2i| \u2212 |\u03b2j||;\n\u2022 ncTFGS: \u03bb 1 i J\u03c4 (|\u03b2i|) + \u03bb2 (i,j)\u2208E J\u03c4 (||\u03b2i| \u2212 |\u03b2j||); 1 http://adni.loni.ucla.edu/ 2 http://cbio.ensmp.fr/\u223cjvert/publi/"}, {"section_title": "Efficiency", "text": "To evaluate the efficiency of the proposed methods, we conduct experiments on a synthetic dataset with a sample size of 100 and dimensions varying from 100 to 3000. The regression model is y = X\u03b2 + \u03b5, where X \u223c N (0, I p\u00d7p), \u03b2i \u223c N (0, 1), and \u03b5 i \u223c N(0, 0.01\n2 ). The graph is randomly generated. The number of edges n e varies from 100 to 3000. The regularization parameters are set as \u03bb 1 = \u03bb2 = 0.8 max{|\u03b2i|} with n e fixed. Since the graph size affects the penalty, \u03bb1 and \u03bb2 are scaled by 1 ne to avoid trivial solutions with dimension p fixed. The average computational time based on 30 repetitions is reported in Figure 2 . As can be seen in Figure 2 , GOSCAR can achieve 1e-4 precision in less than 10s when the dimension and the number of edges are 1000. The computational time of ncTFGS is about 7 times higher than that of GOSCAR in this experiment. The computational time of ncFGS is the same as that of ncTFGS when \u03c4 = 100, and very close to that of ncTFGS when \u03c4 = 0.15. We can also observe that the proposed methods scale very well to the number of edges. The computational time of the proposed method increases less than 4 times when the number of edges increases from 100 to 3000. It is not surprising because the time complexity of each iteration in Algorithm 1 is linear with respect to n e, and the sparsity of T makes the algorithm much more efficient. The increase of dimension is more costly than that of the number of edges, as the complexity of each iteration is quadratic with respect to p. "}, {"section_title": "Simulations", "text": "We use five synthetic problems that have been commonly used in the sparse learning literature [2, 10] \nwith \u03b5 3. Consider a regulatory gene network [10] , where an entire network consists of n T F subnetworks, each with one transcription factor (TF) and its 10 regulatory target genes. The data for each subnetwork can be generated as X"}, {"section_title": "T F i", "text": "\u223c N (0, S11\u00d711) with sii = 1, s1i = s i1 = 0.7, \u2200i, i = 1 and sij = 0 for i = j, j = 1, i = 1. \nWe assume that the features in the same group are connected in a graph, and those in different groups are not connected. We use MSE to measure the performance of estimation of \u03b2, which is defined as\nFor feature grouping and selection, we introduce two separate metrics to measure the accuracy of feature grouping and selection. Denote I i, i = 0, 1, 2, ..., K as the index of different groups, where I 0 is the index of zero coefficients. Then the metric for feature selection is defined as\nand the metric for feature grouping is defined as\nsi measures the grouping accuracy of group i under the assumption that the absolute values of entries in the same group should be the same, but different from those in different groups. s 0 measures the accuracy of feature selection. It is clear that 0 \u2264 s 0, si, s \u2264 1.\nFor each dataset, we generate n samples for training, as well as n samples for testing. To make the synthetic datasets more challenging, we first randomly select n/2 coefficients, and change their signs, as well as those of the corresponding features. Denote\u03b2 andX as the coefficients and features after changing signs. Then\u03b2 i = \u2212\u03b2i,xi = \u2212xi, if the ith coefficient is selected; otherwise,\u03b2 i = \u03b2i,xi = xi. So thatX\u03b2 = X\u03b2. We apply different approaches onX. The covariance matrix of X is used in GFlasso to simulate the graph misspecification. The results of \u03b2 converted from\u03b2 are reported. Figure 3 shows that ncFGS obtains the same results as ncTFGS on dataset 1 with \u03c3 = 2 when \u03c4 is larger than |\u03b2 i|. The regularization parameters are \u03c4 \u03bb1 and \u03c4 \u03bb2 for ncTFGS, and \u03bb 1 and \u03bb2 for ncFGS. Figure 4 shows the average nonzero coefficients obtained on dataset 1 with \u03c3 = 2. As can be seen in Figure 4 , GOSCAR, ncFGS, and ncTFGS are able to utilize the graph information, and achieve good parameter estimation. Although GFlasso can use the graph information, it performs worse than GOSCAR, ncFGS, and ncTFGS due to the graph misspecification. The performance in terms of MSEs averaged over 30 simulations is shown in Table 1 . As indicated in Table 1 , among existing methods (Lasso, GFlasso, OSCAR), GFlasso is the best, except in the two cases where OSCAR is better. GOSCAR is better than the best existing method in all cases except for two, and ncFGS and ncTFGS outperform all the other methods. Table 2 shows the results in terms of accuracy of feature grouping and selection. Since Lasso does not perform feature grouping, we only report the results of the other five methods: OSCAR, GFlasso, GOSCAR, ncFGS, and ncT-FGS. Table 2 shows that ncFGS and ncTFGS achieve higher accuracy than other methods. Table 3 shows the comparison of feature selection alone (\u03bb 2 = 0), feature grouping alone (\u03bb1 = 0), and simultaneous feature grouping and selection using ncTFGS. From Table 3 , we can observe that simultaneous feature grouping and selection outperforms either feature grouping or feature selection, demonstrating the benefit of joint feature grouping and selection in the proposed non-convex method."}, {"section_title": "Real Data", "text": "We conduct experiments on two real datasets: FDG-PET and Breast Cancer. The metrics to measure the performance of different algorithms include accuracy (acc.), sensitivity (sen.), specificity (spe.), degrees of freedom (dof.), and the number of nonzero coefficients (nonzero coeff.). The dof. of lasso is the number of nonzero coefficients [18] . For the algorithms capable of feature grouping, we use the same definition of dof. in [2] , which is the number of estimated groups."}, {"section_title": "FDG-PET", "text": "In this experiment, we use FDG-PET 3D images from 74 Alzheimer's disease (AD), 172 mild cognitive impairment (MCI), and 81 normal control (NC) subjects downloaded from the Alzheimer's disease neuroimaging initiative (ADNI) database. The different regions of whole brain volume can be represented by 116 anatomical volumes of interest (AVOI), defined by Automated Anatomical Labeling (AAL) [20] . Then we extracted data from each of the 116 AVOIs, and derived average of each AVOI for each subject.\nIn our study, we compare different methods in distinguish- ing AD and NC subjects, which is a two-class classification problem over a dataset with 155 samples and 116 features. The dataset is randomly split into two subset, one training set consisting of 104 samples, and one testing set consisting of the remaining 51 samples. The tuning of the parameter is achieved by 5-fold cross validation. Sparse inverse covariance estimation (SICE) has been recognized as an effective tool for identifying the structure of the inverse covariance matrix. We use SICE developed in [6] to model the connectivity of brain regions. Figure 5 shows sample subgraphs built by SICE consisting of 115 nodes and 265 edges.\nThe results based on 20 replications are shown in Table 4 . From Table 4 , we can see that ncTFGS achieves more accurate classification while obtaining smaller degrees of freedom. ncFGS and GOSCAR achieve similar classification, while ncFGS selects more features than GOSCAR. Figure 6 shows the comparison of accuracy with either \u03bb 1 or \u03bb2 fixed. The \u03bb1 and \u03bb2 values range from 1e-4 to 100. As we can see, the performance of ncTFGS is slightly better than that of the other competitors. Since the regularization parameters of subproblems in ncTFGS are , the solution of ncTFGS is more sparse than those of other competitors when \u03bb 1 and \u03bb2 are large and \u03c4 is small (\u03c4 = 0.15 in this case)."}, {"section_title": "Breast Cancer", "text": "We conduct experiments on the breast cancer dataset, which consists of gene expression data for 8141 genes in 295 breast cancer tumors (78 metastatic and 217 non-metastatic). The network described in [4] is used as the input graph in this experiment. Figure 7 shows a subgraph consisting of 80 nodes of the used graph. We restrict our analysis to the 566 genes most correlated to the output, but also connected in the graph. 2/3 data is randomly chosen as training data, and the remaining 1/3 data is used as testing data. The tuning parameter is estimated by 5-fold cross validation. Table 5 shows the results averaged over 30 replications. As indicated in Table 5 , GOSCAR, ncFGS and ncTFGS outperform the other three methods, and ncTFGS achieves the best performance."}, {"section_title": "CONCLUSION", "text": "In this paper, we consider simultaneous feature grouping and selection over a given undirected graph. We propose one convex and two non-convex penalties to encourage both sparsity and equality of absolute values of coefficients for features connected in the graph. We employ ADMM and DC programming to solve the proposed formulations. Numerical experiments on synthetic and real data demonstrate the effectiveness of the proposed methods. Our results also demonstrate the benefit of simultaneous feature grouping and feature selection through the proposed non-convex methods. In this paper, we focus on undirected graphs. A possible future direction is to extend the formulations to directed graphs. In addition, we plan to study the generalization performance of the proposed formulations."}]