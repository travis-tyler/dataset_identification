[{"section_title": "Abstract", "text": "In this work we propose an adversarial learning approach to generate high resolution MRI scans from low resolution images. The architecture, based on the SRGAN model, adopts 3D convolutions to exploit volumetric information. For the discriminator, the adversarial loss uses least squares in order to stabilize the training. For the generator, the loss function is a combination of a least squares adversarial loss and a content term based on mean square error and image gradients in order to improve the quality of the generated images. We explore different solutions for the upsampling phase. We present promising results that improve classical interpolation, showing the potential of the approach for 3D medical imaging super-resolution. Our code is publicly available 1 ."}, {"section_title": "Introduction", "text": "In many medical applications, high resolution images are required to facilitate early and accurate diagnosis. However, due to economical, technological or physical limitations, it may not be easy to obtain images at the desired resolution. Super-resolution techniques solve this problem by creating a High Resolution (HR) image from a Low Resolution one (LR). In the past decade a variety of super-resolution methods have been successfully applied to magnetic resonance imaging (MRI) data to increase the spatial resolution of scans after acquisition has been performed. Approaches can be broadly categorized into reconstruction-based and learning-based methods [1] . Within the second group, solutions based on deep learning are currently being investigated motivated by the success of deep learning models in many computer vision tasks [2, 3] . In particular, Generative Adversarial Networks (GANs) [4] are a very promising approach for image generation, and have been also used for super-resolution [5] . Recently, different architectures and loss functions that try to improve the quality of the images generated using GANs have been presented [6, 7, 8] . However, these approaches have been proposed for 2D data.\nIn this work we propose an architecture for MRI super-resolution that completely exploits the available volumetric information contained in MRI scans, using 3D convolutions to process the volumes and taking advantage of an adversarial framework, improving the realism of the generated volumes. The model is based on the SRGAN network [5] . The adversarial loss uses least squares to stabilize the training and the generator loss, in addition to the adversarial term contains a content term based on mean square error and image gradients in order to improve the quality of the generated images. We explore three different methods for the upsampling phase: an upsampling layer which uses nearest neighbors to replicate consecutive pixels followed by a convolutional layer to improve the approximation, sub-pixel convolution layers as proposed in [9] and a modification of this method [10] that alleviates checkbock artifacts produced by sub-pixel convolution layers [11] ."}, {"section_title": "Method", "text": ""}, {"section_title": "Generative Adversarial Networks", "text": "GANs [4] are generative models that consist of a generator G and a discriminator D that compete in a two-player minimax game. The target of G is to learn the distribution over data x starting from sampling input variables from a uniform or Gaussian distribution p z (z), while the discriminator D is typically a binary classifier that tries to decide whether a sample is from the training data or has been generated by G.\nThe two players learn by means of an adversarial training, where G has to learn how to cheat D, making the images perceptually closer to the input data, while D has to recognize efficiently the real samples from the fake ones. The process is formulated with the following minimax objective:\nIn the case of image super-resolution, the goal is to generate a high resolution image I SR from a low resolution input image I LR . The image I LR is a low-resolution version of a high-resolution image I HR , obtained by applying a Gaussian filter and a downsampling operator with downsampling factor r. The high-resolution images I HR are only available during training. The generator G is a convolutional neural network that is trained to generate a high resolution counterpart from a low resolution input image. The discriminator D is another neural network that tries to differentiate the generated I SR from the real I HR .\nDue to the adversarial formulation GANs may be difficult to train; it is necessary to provide a balance between both players, so neither of them can outperform the other. For that reason, different methods and architectures have been proposed recently to make GANs more stable, and also to increase the quality of the images. Examples of these methods, that we incorporate in our model, are the following: the use of batch normalization in all layers (except in the G output and D input), one-side label smoothing to prevent extreme extrapolation behavior in the discriminator and reduce its confidence and the use of loss functions that avoid the vanishing gradient problem of the classical approach and helps to stabilize the training."}, {"section_title": "Architecture", "text": "Our network architecture ( Fig. 1 and Fig. 2 ) is based on the SRGAN model [5] . The main difference is found in the convolutional filters; in our architecture, to be able to deal with volumetric information we use 3D convolutional layers. Furthermore, we introduce changes in the loss function, both to make the network more stable and to improve the quality of the generated images. These changes will be explained in section 2.4.\nThe discriminator network is composed of eight convolutional layers with 3x3x3 kernels. The number of filters increases by a factor of 2 from 32 to 256. Strided convolutions are used to reduce the image resolution each time the number of features is doubled. After the convolutional layers, there are two dense layers and a final sigmoid activation that outputs a probability indicating whether the input image is real or fake.\nFor the generator, we use six residual blocks composed of a convolution with 32 filters of size 3x3x3, batch normalization, LeakyReLU activation and another convolution with the same parameters and batch normalization. As in the SRGAN network, there are connections between input and output in the residual blocks, and between the input of the first residual block and the output of the last residual block, allowing the network to access low level features and improve the quality of the generated images. After the residual blocks, there are upsampling blocks that increase the resolution of the input image. Each block up-samples the image by a factor of 2, so blocks are replicated in order to obtain higher upsampling factors. We explore different configurations for the upsampling blocks that are explained in the following section. Figure 3 shows the configuration of the different methods used for the upsampling blocks in the generator network. In the following, we describe each low-resolution volume by a real valued tensor of size H \u00d7 W \u00d7 D \u00d7 C, and the high-resolution volume by rH \u00d7 rW \u00d7 rD \u00d7 C, where r is the downsampling factor, H, W , D and C are the height, width, depth and number of channels, respectively."}, {"section_title": "Upsampling methods", "text": ""}, {"section_title": "Resize convolution", "text": "The first method upscales the input feature maps using nearest neighbor interpolation, and then employs a standard convolutional layer with both input and output in the higher resolution space."}, {"section_title": "Sub-pixel convolution", "text": "An efficient way to increase the resolution of a 2D image was proposed in [12] . In their work, the method to perform the upsampling operation consists of a convolutional layer followed by a pixel-shuffler that arranges the result of the convolution with shape H \u00d7 W \u00d7 Cr 2 into a tensor of size rH \u00d7 rW \u00d7 C. In our case, since we are dealing with 3D volumes, the size of the initial tensor is H \u00d7 W \u00d7 D \u00d7 Cr 3 and is finally arranged into a tensor of size rH \u00d7 rW \u00d7 rD \u00d7 C. This method is equivalent to a deconvolution operation with stride 2 as observed in [13] . Moreover, sub-pixel convolutions can be interpreted as a standard convolution in low-resolution space followed by a periodic shuffling operation.\nFollowing this interpretation, we create a set of kernels that, rearranged, will build the HR image. Given a volume of size H \u00d7 W \u00d7 D \u00d7 C, convolved by a set of kernels (nf, C, k, k, k) (where nf is the number of filters of size k \u00d7 k \u00d7 k) after computing the pixel-shuffling operation we have a volume of size rH \u00d7 rW \u00d7 rD \u00d7 nf r 3 . Here, note that by rearranging pixels the feature maps (output channels after the convolution) are mixed, creating consecutive pixels.\nThe advantage of this method over resize convolution is that with the same computational complexity, it has more parameters, improving the modeling power of the network. However, it suffers from checkerboard artifacts since consecutive pixels depend on different feature maps that are independently randomly initialized."}, {"section_title": "Convolution nearest neighbor resize", "text": "A modification of the sub-pixel convolution was proposed in [10] in order to remove the checkerboard artifacts produced by random initialization while maintaining the number of trainable parameters. Resize convolution produces upsampled images free of checkerboard artifacts. For that reason, if the sub-pixel operation is made identical to a nearest neighbor resize after the initialization step, the advantages of the sub-pixel method will be preserved, while eliminating the undesired artifacts.\nThe method consists on performing first a deconvolution operation with stride 2 (equivalent to pixelshuffling after convolution) with kernels initialized with size (nf, nf r 3 , k, k, k). Then, an upsampling of this initialization is performed to finally compute the deconvolution layer with filters of size (nf, nf r 3 , kr, kr, kr)."}, {"section_title": "Loss function", "text": "A very critical point when designing a GAN is the definition of the loss function. Many methods have been proposed recently to stabilize the training and improve the quality of the synthesized images.\nOne of these works is [8] , where the behavior of the sigmoid cross entropy loss function, commonly used in the classic GANs framework is studied; this loss function causes the problem of vanishing gradients for the samples that lie far away from the correct decision boundary. To overcome this problem a loss function based on least-squares is proposed (LSGAN), substituting the cross-entropy loss by a least square function with binary coding (1 for real, 0 for fake)."}, {"section_title": "Using this formulation, equation 1 changes to:", "text": "Discriminator loss: In our super-resolution model, the adversarial loss used for the discriminator is l\nGenerator loss: The loss function used for the generator is a combination of an adversarial term and a content term, as proposed in [5] (in our experiments we use \u03b1 = 10 \u22123 ):\nThe adversarial loss is based on least squares:\nwhile the content loss is a combination of two terms l\nThe first term is the mean squared error (MSE) between the original high resolution image I HR and the super resolved image I SR , calculated as\nThe pixel-wise MSE loss help to achieve high PSNR values, but tends to create blurry images. In order to improve the quality of the samples, an image gradient-based loss term is used as proposed in [14] .\nThis Gradient Difference Loss (GDL) sharpens the image prediction by penalizing the differences of image gradient predictions."}, {"section_title": "Experiments and Results", "text": "We perform our experiments using a set of normal control T1-weighted images from the Alzheimer's Disease Neuroimaging Initiative (ADNI) database (see www.adni-info.org for details). Skull stripping is performed in all volumes and part of the background is removed. Final volumes have dimensions 224x224x152.\nDue to memory constraints the training is patch-based; for each volume we extract patches of size 128x128x92, with a step of 112x112x76, so there are 8 patches per volume, with an overlap of 16x16x16. We have a total number of 589 volumes, 470 are used for training while 119 are used for testing. We use batches of two patches, thus for each volume we perform 4 iterations. We use Adam optimization for both the generator and the discriminator, while the learning rate for the generator is set to 1e-5 and for the discriminator 1e-4.\nTo evaluate the quality of the images synthesized by our model we make two sets of experiments, using the original MRI volumes as ground truth and training the network with downsampled versions of the images by factors 2 and 4, using the three upsampling strategies described in Section 2.3. In the following, Subpixel stands for sub-pixel convolution and Subpixel-NN stands for convolution nearest neighbor resize. We have also compared the performance of our model with a classical cubic spline interpolation. The generated volumes are compared to the ground-truth volumes in terms of peak signal-to-noiseratio (PSNR) and structural similarity index measure (SSIM). Numerical results can be found in Table 1 . We observe that the resize convolution upsampling method outperforms the others in terms of SSIM a metric that is closer to human visual perception than the PSNR, while sub-pixel nearest neighbor convolution is the best in terms of PSNR.\nIn produces perceptually better results. While the changes proposed by the sub-pixel nearest neighbor convolution method improve the behavior of the original sub-pixel convolution, this upsampling method still produce some checkboard artifacts in our images."}, {"section_title": "Conclusions", "text": "In this work a method for MRI super-resolution has been implemented within the generative adversarial framework. We use an adversarial term loss in the generator loss to create more realistic samples, and a content loss to reduce the differences between real and generated images. We present promising results that improve classical interpolation when the downsampling factor is high, showing the potential of the approach for 3D medical imaging super-resolution. Possible future work involves the exploration of better architectures and the inclusion of other perceptual terms in the loss function in order to increase the quality of the generated volumes. Further experiments need to be done using other datasets and comparing the performance of this approach to other methods. Also a mean opinion score (MOS) test should be performed to evaluate the ability of the method to generate perceptually convincing images. This is an important issue since minor errors in the reconstruction might lead to big differences in clinical interpretation. "}]