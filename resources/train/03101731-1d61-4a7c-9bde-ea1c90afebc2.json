[{"section_title": "Abstract", "text": "Abstract"}, {"section_title": "INTRODUCTION", "text": "Alzheimer's disease (AD) is the most frequent neurodegenerative dementia and a growing health problem. Early and accurate diagnosis of Alzheimer's Disease (AD) is not only challenging, but is crucial in the perspective of future treatment. There are basically 3 stages in Alzheimer disease. Those are cognitive normal (CN), mild cognitive impairment (MCI) and Alzheimer disease (AD) [1] . The key to early diagnosis and treatment is the recognition of mild cognitive impairment. Patients suffering from AD at a prodromal stage are, mostly, clinically classified as amnestic mild cognitive impairment (MCI) but not all patients with amnestic MCI will develop AD. Distinguishing mild cognitive impairment from cognitive normalcy by clinical means is a challenging task. The onset of cognitive impairment is recognizable as structural abnormality in the brain even before the subject begins to show clinical symptoms. This makes brain imaging a potential tool in early diagnosis of Alzheimer's Disease. The modality we used here is T1 weighted MRI. Advantages of MRI over other imaging modalities are its high spatial resolution and excellent discrimination of soft tissues [2] .\nAdvances in statistical learning with the development of new machine learning algorithms capable of dealing with high dimensional data, such as support vector machine (SVM), enable the development of new diagnostic tools based on T1-weighted MRI. Recently, several approaches have been proposed to automatically classify patients with AD and/or MCI from anatomical MRI. These approaches could have the potential to assist in the early diagnosis of AD. These approaches can roughly be grouped into three different categories, depending on the type of features extracted from the MRI (voxel-based, vertex-based or ROI-based). In the first category, the features are defined at the level of the MRI voxel. Specifically, the features are the probability of the different tissue classes (grey matter, white matter and cerebrospinal fluid) in a given voxel directly classified grey matter features with an SVM [3] . All other methods first reduce the dimensionality of the feature space using different types of features extraction and/or selection methods used smoothing, voxel-down sampling, and then a feature selection step. Another solution is to group voxels into anatomical regions through the registration with a labeled atlas. In the second category, the features are defined at the vertex-level on the cortical surface. The methods of the third category include only the hippocampus [4] . Their approach is based on the analysis of the volume and/or shape of the hippocampus. The goal of this work is to investigate the efficacy of sparse dictionary learning in addressing the problem of classification of patients with AD based on anatomical MRI, using the same study population. To that purpose, we used the Alzheimer's Disease Neuroimaging Initiative (ADNI) database. We evaluated the performance of sparse learning against SVM which is one of the most successful data classification tools [5] . Voxel based approach was used for feature selection. The paper is organized into 5 sections. Section 1 presents an introductory discussion of the problem. Section 2 introduces Sparse Dictionary Learning. Section 3 is about Data and Methods used such as patch extraction and sparse method of classification. Section 4 presents the results and discussion and finally Section 5 concludes the paper."}, {"section_title": "SPARSE REPRESENTATION", "text": "Recent years have seen a surge in interest in the sparse representation. A collection of data vectors are represented using an over-complete dictionary, D=R nxK where \"n\" is the dimension of the data-space and \"K\" is an integer greater than n. Assuming a linear model of data generation the data vectors are represented as a linear combination of the dictionaryatoms [6] . Since the number of dictionary-atoms is greater than the dimension of the data-space it is possible to have an exact representation of any vector in the data-space. In sparse representation the accuracy of the linear combination is coupled with a sparsity factor. This results in generating representation that is accurate and sparse at the same time. In simple mathematical terms sparse representation problem can be expressed in either of the following ways. \nWhere ||a|| p is the l p norm defined as\na is the number of non-zero elements in \"a\". Extraction of the sparsest representation is a hard problem that has been extensively studied. In sparse-coding [7] the dictionary D is assumed to be known a priori and fixed. The drawback of this approach is that the dictionary might not be suitable to capture the intricate characteristics of the data. This innate deficiency of fixed dictionary lead to the development of algorithms that deduce prototype vectors from the available data samples itself. Section II A introduces the sparse-coding stage based on a fixed dictionary. Section II B discusses the update on the dictionary-atoms to better fit the data."}, {"section_title": "Sparse Coding", "text": "Sparse-coding is the process of computing the representation x of a data vector y given the dictionary. Exact solution of the problems 1 or 2 is NP hard and hence approximate solutions are sought for. In this paper we discuss the simplest of the approaches namely the Orthogonal Matching Pursuit (OMP) which is a generalization of the clustering problem. Clustering can be interpreted as identifying the closest vector from a group of prototype vectors and assigning a label to the data vector according to the prototype vector it is most closely associated. Clustering provides a compressed representation of the data where each data sample is approximated by its closest prototype vector. Hence, it can be construed as a special case of sparse-coding where for each data the representation is composed of a single non-zero component [8] . In our work, the sparse-coding phase is addressed using OMP algorithm. The pseudo-code listed taken from [9] below gives the OMP algorithm. OMP is an iterative procedure where in the i th iteration the i th closest dictionary atom is chosen and the projection of the data-vector on the selected dictionary-atom is added to the representation vector. This is iterated L times where L is the required l 0 norm of the sparsecode. The optimization problem that OMP addresses is: "}, {"section_title": "Sparse Dictionary Learning", "text": "Once a representation of the data with respect to an initially assumed dictionary is computed the next step is to update the dictionary [10] . Each dictionary atom is updated to make it closer to the subset of data-vectors for which it has a non-zero contribution in the sparse representation. Denoting by Y the collection of data-vectors and by X the sparse-codes of the data-vectors obtained in the previous stage the error associated is defined as:\nThis can be expanded using the dictionary atoms: "}, {"section_title": "org 743", "text": "Separating the term containing the relevant dictionary atom we get an equivalent expression\nWhere E k = y-\u03a3 i\u2260k d i x i T .\nDictionary update in KSVD algorithm [11] minimizes the error by minimizing the difference between E k and d k x T k . That is it finds nearest rank-1 approximation to E k and updates d k . The best approximation is obtained by the using the vectors corresponding to the largest singular value of E k . The algorithms involving the two stages are given below [12] ."}, {"section_title": "Algorithm 2 KSVD", "text": ""}, {"section_title": "1.", "text": "Input: NXM Matrix of data vectors Y, N is the dimension, M is the no. of vectors and K is the number of dictionary-atoms."}, {"section_title": "2.", "text": "Output: Sparse Representation Y, Dictionary D. For\nIf ||E|| 2 <\u019f go to step 4."}, {"section_title": "DATA AND PROPOSED METHODS", "text": "The objective of the work as stated earlier is to investigate the potential of sparse learning in AD diagnosis. We choose to use the standard bench mark data ADNI presented in the Table  1 for our study. The dimensions of the brain volume are 91x109x91. Since this work is preliminary investigation to test our intuition about the possible use of sparse learning methods as a diagnostic tool for AD, we decided on using a single slice containing enough cortical region to extract voxel features. 55 th slice was used for the study. Below Fig 1 shows the relevant slice of brain and brain affiliated with AD and MCI."}, {"section_title": "Fig-1: Normal, AD, MCI", "text": "The volumes were preprocessed before the slice and the voxels were selected. The preprocessing steps are basically done in 3 stages-Brain extraction, image registration and segmentation respectively.\nPreprocessing was done using FSL toolbox http://fsl.fmrib.ox.ac.uk/fsl/fslwiki/. MRI image contain some unnecessary portions like skull and noise. Using the Brain Extraction we will get only the portion of brain excluding the skull. Image registration is used to register all other images to a standard template image. MNI152 is used a standard template image. The brain extracted, co-registered image is segmented into GM, WM and CSF using FAST segmentation tool box in FSL. We chose grey matter for the classification.\nSince the slice chosen contains a large number of cortical voxels, its direct vectorization results in high dimensionality. To address this problem we chose patches uniformly distributed over the cortical surface. These patches are vectorized and concatenated to obtain a vector representing the slice. Since the patch distribution is random and uniform, when taken over a number of images they collectively contain enough features for the algorithms to distinguish the underlying classes. The algorithm of feature selection is described below."}, {"section_title": "Patch Extraction Algorithm", "text": "After extraction of the grey matter, from the MR images, it is required to select the patches. For simplicity, we uniformly select the patches of fixed size(pxp) from the MR images. We select the significant j number of patches from each image and used the data matrix for the training of SVM and K-SVD. The vectors obtained as detailed above were used as input data for both SVM and Sparse dictionary method."}, {"section_title": "Sparse Method of Classification", "text": "The patch extraction algorithm extracts N patches of size PxP from a slice and concatenates them into an NP 2 \u00d71 vector. The vectors extracted so form the training data for each class. Denote it by \u0454 A similar approach is used in automatic face recognition by [13] . But the proposed idea is different from [13] as they use l 1 minimization and use the training vectors directly as the dictionary atoms. In the algorithm presented below Dad, Dcn are the dictionaries of AD and CN obtained, after applying the KSVD algorithm by using their data respectively. The pseudo code for classification between AD and CN classes is given the following listing: Where TP, TN, FP and FN are the number of true positives, true negatives, false positives and false negatives respectively [14] . These probabilities reveal the ability to detect AD, CN or MCI patterns thus, the best algorithm is the one that achieves the best specificity and sensitivity. The results of both the methods were presented in the table 2 and table 3 . "}, {"section_title": "RESULTS COMPARISION", "text": ""}, {"section_title": "CONCLUSIONS", "text": "In this paper, we have investigated using the K-SVD for classification of high dimensional MRI data. Furthermore, we have presented a random patch based classification with the K-SVD. The local patches are extracted from the relevant regions to capture the local spatial consistency and are randomly sampled to construct a feature subspace. Then, multiple classifiers are combined to make more accurate and robust classification. The experimental results on ADNI database show that K-SVD achieves better classification performance than SVM classifier when features are used for classification. In the current paper, we validate our method using MRI data from ADNI. However, other modality of data can also be used in our method. "}]